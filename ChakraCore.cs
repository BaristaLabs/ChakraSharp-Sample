//----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace ChakraSharp
{
    public enum JsParseModuleSourceFlags
    {
        JsParseModuleSourceFlags_DataIsUTF16LE = 0,
        JsParseModuleSourceFlags_DataIsUTF8 = 1
    }

    public enum JsModuleHostInfoKind
    {
        JsModuleHostInfo_Exception = 1,
        JsModuleHostInfo_HostDefined = 2,
        JsModuleHostInfo_NotifyModuleReadyCallback = 3,
        JsModuleHostInfo_FetchImportedModuleCallback = 4
    }

    public class JsModuleRecord { }

    /// <summary>
    /// <para>User implemented callback to fetch additional imported modules.</para>
    /// </summary>
    /// <remarks>
    /// <para>Notify the host to fetch the dependent module. This is the &quot;import&quot; part before HostResolveImportedModule in ES6 spec.</para>
    /// <para>This notifies the host that the referencing module has the specified module dependency, and the host need to retrieve the module back.</para>
    /// </remarks>
    /// <param name="referencingModule">
    /// <para>The referencing module that is requesting the dependency modules.</para>
    /// </param>
    /// <param name="specifier">
    /// <para>The specifier coming from the module source code.</para>
    /// </param>
    /// <param name="dependentModuleRecord">
    /// <para>The ModuleRecord of the dependent module. If the module was requested before from other source, return the existing ModuleRecord, otherwise return a newly created ModuleRecord.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate _JsErrorCode FetchImportedModuleCallBack(global::System.IntPtr referencingModule, global::System.IntPtr specifier, global::System.IntPtr dependentModuleRecord);

    /// <summary>
    /// <para>User implemented callback to get notification when the module is ready.</para>
    /// </summary>
    /// <remarks>
    /// <para>Notify the host after ModuleDeclarationInstantiation step (15.2.1.1.6.4) is finished. If there was error in the process, exceptionVar</para>
    /// <para>holds the exception. Otherwise the referencingModule is ready and the host should schedule execution afterwards.</para>
    /// </remarks>
    /// <param name="referencingModule">
    /// <para>The referencing module that have finished running ModuleDeclarationInstantiation step.</para>
    /// </param>
    /// <param name="exceptionVar">
    /// <para>If nullptr, the module is successfully initialized and host should queue the execution job otherwise it's the exception object.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate _JsErrorCode NotifyModuleReadyCallback(global::System.IntPtr referencingModule, global::System.IntPtr exceptionVar);

    /// <summary>
    /// <para>Called by the runtime to load the source code of the serialized script.</para>
    /// </summary>
    /// <param name="sourceContext">
    /// <para>The context passed to Js[Parse|Run]SerializedScriptCallback</para>
    /// </param>
    /// <param name="script">
    /// <para>The script returned.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate bool JsSerializedLoadScriptCallback(ulong sourceContext, global::System.IntPtr value, _JsParseScriptAttributes* parseAttributes);

    public unsafe partial class ChakraCore
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsInitializeModuleRecord")]
            internal static extern _JsErrorCode JsInitializeModuleRecord_0(global::System.IntPtr referencingModule, global::System.IntPtr normalizedSpecifier, global::System.IntPtr* moduleRecord);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsParseModuleSource")]
            internal static extern _JsErrorCode JsParseModuleSource_0(global::System.IntPtr requestModule, ulong sourceContext, byte* script, uint scriptLength, JsParseModuleSourceFlags sourceFlag, global::System.IntPtr* exceptionValueRef);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsModuleEvaluation")]
            internal static extern _JsErrorCode JsModuleEvaluation_0(global::System.IntPtr requestModule, global::System.IntPtr* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSetModuleHostInfo")]
            internal static extern _JsErrorCode JsSetModuleHostInfo_0(global::System.IntPtr requestModule, JsModuleHostInfoKind moduleHostInfo, global::System.IntPtr hostInfo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetModuleHostInfo")]
            internal static extern _JsErrorCode JsGetModuleHostInfo_0(global::System.IntPtr requestModule, JsModuleHostInfoKind moduleHostInfo, global::System.IntPtr* hostInfo);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateString")]
            internal static extern _JsErrorCode JsCreateString_0([MarshalAs(UnmanagedType.LPStr)] string content, ulong length, global::System.IntPtr* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateStringUtf16")]
            internal static extern _JsErrorCode JsCreateStringUtf16_0(ushort* content, ulong length, global::System.IntPtr* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCopyString")]
            internal static extern _JsErrorCode JsCopyString_0(global::System.IntPtr value, sbyte* buffer, ulong bufferSize, uint* written);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCopyStringUtf16")]
            internal static extern _JsErrorCode JsCopyStringUtf16_0(global::System.IntPtr value, int start, int length, ushort* buffer, uint* written);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsParse")]
            internal static extern _JsErrorCode JsParse_0(global::System.IntPtr script, ulong sourceContext, global::System.IntPtr sourceUrl, _JsParseScriptAttributes parseAttributes, global::System.IntPtr* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsRun")]
            internal static extern _JsErrorCode JsRun_0(global::System.IntPtr script, ulong sourceContext, global::System.IntPtr sourceUrl, _JsParseScriptAttributes parseAttributes, global::System.IntPtr* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreatePropertyId")]
            internal static extern _JsErrorCode JsCreatePropertyId_0([MarshalAs(UnmanagedType.LPStr)] string name, ulong length, global::System.IntPtr* propertyId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCopyPropertyId")]
            internal static extern _JsErrorCode JsCopyPropertyId_0(global::System.IntPtr propertyId, sbyte* buffer, ulong bufferSize, uint* length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSerialize")]
            internal static extern _JsErrorCode JsSerialize_0(global::System.IntPtr script, global::System.IntPtr* buffer, _JsParseScriptAttributes parseAttributes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsParseSerialized")]
            internal static extern _JsErrorCode JsParseSerialized_0(global::System.IntPtr buffer, global::System.IntPtr scriptLoadCallback, ulong sourceContext, global::System.IntPtr sourceUrl, global::System.IntPtr* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsRunSerialized")]
            internal static extern _JsErrorCode JsRunSerialized_0(global::System.IntPtr buffer, global::System.IntPtr scriptLoadCallback, ulong sourceContext, global::System.IntPtr sourceUrl, global::System.IntPtr* result);
        }

        /// <summary>
        /// <para>Initialize a ModuleRecord from host</para>
        /// </summary>
        /// <remarks>
        /// <para>Bootstrap the module loading process by creating a new module record.</para>
        /// </remarks>
        /// <param name="referencingModule">
        /// <para>The referencingModule as in HostResolveImportedModule (15.2.1.17). nullptr if this is the top level module.</para>
        /// </param>
        /// <param name="normalizedSpecifier">
        /// <para>The host normalized specifier. This is the key to a unique ModuleRecord.</para>
        /// </param>
        /// <param name="moduleRecord">
        /// <para>The new ModuleRecord created. The host should not try to call this API twice with the same normalizedSpecifier. chakra will return an existing ModuleRecord if the specifier was passed in before.</para>
        /// </param>
        public static _JsErrorCode JsInitializeModuleRecord(global::System.IntPtr referencingModule, global::System.IntPtr normalizedSpecifier, out global::System.IntPtr moduleRecord)
        {
            global::System.IntPtr _moduleRecord;
            var __arg2 = &_moduleRecord;
            var __ret = __Internal.JsInitializeModuleRecord_0(referencingModule, normalizedSpecifier, __arg2);
            moduleRecord = _moduleRecord;
            return __ret;
        }

        /// <summary>
        /// <para>Parse the module source</para>
        /// </summary>
        /// <remarks>
        /// <para>This is basically ParseModule operation in ES6 spec. It is slightly different in that the ModuleRecord was initialized earlier, and passed in as an argument.</para>
        /// </remarks>
        /// <param name="requestModule">
        /// <para>The ModuleRecord that holds the parse tree of the source code.</para>
        /// </param>
        /// <param name="sourceContext">
        /// <para>A cookie identifying the script that can be used by debuggable script contexts.</para>
        /// </param>
        /// <param name="script">
        /// <para>The source script to be parsed, but not executed in this code.</para>
        /// </param>
        /// <param name="scriptLength">
        /// <para>The source length of sourceText. The input might contain embedded null.</para>
        /// </param>
        /// <param name="sourceFlag">
        /// <para>The type of the source code passed in. It could be UNICODE or utf8 at this time.</para>
        /// </param>
        /// <param name="exceptionValueRef">
        /// <para>The error object if there is parse error.</para>
        /// </param>
        public static _JsErrorCode JsParseModuleSource(global::System.IntPtr requestModule, ulong sourceContext, byte* script, uint scriptLength, JsParseModuleSourceFlags sourceFlag, out global::System.IntPtr exceptionValueRef)
        {
            global::System.IntPtr _exceptionValueRef;
            var __arg5 = &_exceptionValueRef;
            var __ret = __Internal.JsParseModuleSource_0(requestModule, sourceContext, script, scriptLength, sourceFlag, __arg5);
            exceptionValueRef = _exceptionValueRef;
            return __ret;
        }

        /// <summary>
        /// <para>Execute module code.</para>
        /// </summary>
        /// <remarks>
        /// <para>This method implements 15.2.1.1.6.5, &quot;ModuleEvaluation&quot; concrete method.</para>
        /// <para>When this methid is called, the chakra engine should have notified the host that the module and all its dependent are ready to be executed.</para>
        /// <para>One moduleRecord will be executed only once. Additional execution call on the same moduleRecord will fail.</para>
        /// </remarks>
        /// <param name="requestModule">
        /// <para>The module to be executed.</para>
        /// </param>
        /// <param name="result">
        /// <para>The return value of the module.</para>
        /// </param>
        public static _JsErrorCode JsModuleEvaluation(global::System.IntPtr requestModule, out global::System.IntPtr result)
        {
            global::System.IntPtr _result;
            var __arg1 = &_result;
            var __ret = __Internal.JsModuleEvaluation_0(requestModule, __arg1);
            result = _result;
            return __ret;
        }

        /// <summary>
        /// <para>Set the host info for the specified module.</para>
        /// </summary>
        /// <param name="requestModule">
        /// <para>The request module.</para>
        /// </param>
        /// <param name="moduleHostInfo">
        /// <para>The type of host info to be set.</para>
        /// </param>
        /// <param name="hostInfo">
        /// <para>The host info to be set.</para>
        /// </param>
        public static _JsErrorCode JsSetModuleHostInfo(global::System.IntPtr requestModule, JsModuleHostInfoKind moduleHostInfo, global::System.IntPtr hostInfo)
        {
            var __ret = __Internal.JsSetModuleHostInfo_0(requestModule, moduleHostInfo, hostInfo);
            return __ret;
        }

        /// <summary>
        /// <para>Retrieve the host info for the specified module.</para>
        /// </summary>
        /// <param name="requestModule">
        /// <para>The request module.</para>
        /// </param>
        /// <param name="moduleHostInfo">
        /// <para>The type of host info to get.</para>
        /// </param>
        /// <param name="hostInfo">
        /// <para>The host info to be retrieved.</para>
        /// </param>
        public static _JsErrorCode JsGetModuleHostInfo(global::System.IntPtr requestModule, JsModuleHostInfoKind moduleHostInfo, out global::System.IntPtr hostInfo)
        {
            global::System.IntPtr _hostInfo;
            var __arg2 = &_hostInfo;
            var __ret = __Internal.JsGetModuleHostInfo_0(requestModule, moduleHostInfo, __arg2);
            hostInfo = _hostInfo;
            return __ret;
        }

        /// <summary>
        /// <para>Create JavascriptString variable from ASCII or Utf8 string</para>
        /// </summary>
        /// <remarks>
        /// <para>Input string can be either ASCII or Utf8</para>
        /// </remarks>
        /// <param name="content">
        /// <para>Pointer to string memory.</para>
        /// </param>
        /// <param name="length">
        /// <para>Number of bytes within the string</para>
        /// </param>
        /// <param name="value">
        /// <para>JsValueRef representing the JavascriptString</para>
        /// </param>
        public static _JsErrorCode JsCreateString(string content, ulong length, out global::System.IntPtr value)
        {
            global::System.IntPtr _value;
            var __arg2 = &_value;
            var __ret = __Internal.JsCreateString_0(content, length, __arg2);
            value = _value;
            return __ret;
        }

        /// <summary>
        /// <para>Create JavascriptString variable from Utf16 string</para>
        /// </summary>
        /// <remarks>
        /// <para>Expects Utf16 string</para>
        /// </remarks>
        /// <param name="content">
        /// <para>Pointer to string memory.</para>
        /// </param>
        /// <param name="length">
        /// <para>Number of characters within the string</para>
        /// </param>
        /// <param name="value">
        /// <para>JsValueRef representing the JavascriptString</para>
        /// </param>
        public static _JsErrorCode JsCreateStringUtf16(ref ushort content, ulong length, out global::System.IntPtr value)
        {
            fixed (ushort* __refParamPtr0 = &content)
            {
                var __arg0 = __refParamPtr0;
                global::System.IntPtr _value;
                var __arg2 = &_value;
                var __ret = __Internal.JsCreateStringUtf16_0(__arg0, length, __arg2);
                value = _value;
                return __ret;
            }
        }

        /// <summary>
        /// <para>Write JavascriptString value into C string buffer (Utf8)</para>
        /// </summary>
        /// <remarks>
        /// <para>When size of the `buffer` is unknown,</para>
        /// <para>`buffer` argument can be nullptr.</para>
        /// <para>In that case, `written` argument will return the length needed.</para>
        /// </remarks>
        /// <param name="value">
        /// <para>JavascriptString value</para>
        /// </param>
        /// <param name="buffer">
        /// <para>Pointer to buffer</para>
        /// </param>
        /// <param name="bufferSize">
        /// <para>Buffer size</para>
        /// </param>
        /// <param name="written">
        /// <para>Total number of characters written</para>
        /// </param>
        public static _JsErrorCode JsCopyString(global::System.IntPtr value, sbyte* buffer, ulong bufferSize, out uint written)
        {
            fixed (uint* __refParamPtr3 = &written)
            {
                var __arg3 = __refParamPtr3;
                var __ret = __Internal.JsCopyString_0(value, buffer, bufferSize, __arg3);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Write string value into Utf16 string buffer</para>
        /// </summary>
        /// <remarks>
        /// <para>When size of the `buffer` is unknown,</para>
        /// <para>`buffer` argument can be nullptr.</para>
        /// <para>In that case, `written` argument will return the length needed.</para>
        /// <para></para>
        /// <para>when start is out of range or &lt; 0, returns JsErrorInvalidArgument</para>
        /// <para>and `written` will be equal to 0.</para>
        /// <para>If calculated length is 0 (It can be due to string length or `start`</para>
        /// <para>and length combination), then `written` will be equal to 0 and call</para>
        /// <para>returns JsNoError</para>
        /// </remarks>
        /// <param name="value">
        /// <para>JavascriptString value</para>
        /// </param>
        /// <param name="start">
        /// <para>start offset of buffer</para>
        /// </param>
        /// <param name="length">
        /// <para>length to be written</para>
        /// </param>
        /// <param name="buffer">
        /// <para>Pointer to buffer</para>
        /// </param>
        /// <param name="written">
        /// <para>Total number of characters written</para>
        /// </param>
        public static _JsErrorCode JsCopyStringUtf16(global::System.IntPtr value, int start, int length, ref ushort buffer, out uint written)
        {
            fixed (ushort* __refParamPtr3 = &buffer)
            {
                var __arg3 = __refParamPtr3;
                fixed (uint* __refParamPtr4 = &written)
                {
                    var __arg4 = __refParamPtr4;
                    var __ret = __Internal.JsCopyStringUtf16_0(value, start, length, __arg3, __arg4);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Parses a script and returns a function representing the script.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// <para></para>
        /// <para>Script source can be either JavascriptString or JavascriptExternalArrayBuffer.</para>
        /// <para>In case it is an ExternalArrayBuffer, and the encoding of the buffer is Utf16,</para>
        /// <para>JsParseScriptAttributeArrayBufferIsUtf16Encoded is expected on parseAttributes.</para>
        /// <para></para>
        /// <para>Use JavascriptExternalArrayBuffer with Utf8/ASCII script source</para>
        /// <para>for better performance and smaller memory footprint.</para>
        /// </remarks>
        /// <param name="script">
        /// <para>The script to run.</para>
        /// </param>
        /// <param name="sourceContext">
        /// <para>A cookie identifying the script that can be used by debuggable script contexts.</para>
        /// </param>
        /// <param name="sourceUrl">
        /// <para>The location the script came from.</para>
        /// </param>
        /// <param name="parseAttributes">
        /// <para>Attribute mask for parsing the script</para>
        /// </param>
        /// <param name="result">
        /// <para>The result of the compiled script.</para>
        /// </param>
        public static _JsErrorCode JsParse(global::System.IntPtr script, ulong sourceContext, global::System.IntPtr sourceUrl, _JsParseScriptAttributes parseAttributes, out global::System.IntPtr result)
        {
            global::System.IntPtr _result;
            var __arg4 = &_result;
            var __ret = __Internal.JsParse_0(script, sourceContext, sourceUrl, parseAttributes, __arg4);
            result = _result;
            return __ret;
        }

        /// <summary>
        /// <para>Executes a script.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// <para></para>
        /// <para>Script source can be either JavascriptString or JavascriptExternalArrayBuffer.</para>
        /// <para>In case it is an ExternalArrayBuffer, and the encoding of the buffer is Utf16,</para>
        /// <para>JsParseScriptAttributeArrayBufferIsUtf16Encoded is expected on parseAttributes.</para>
        /// <para></para>
        /// <para>Use JavascriptExternalArrayBuffer with Utf8/ASCII script source</para>
        /// <para>for better performance and smaller memory footprint.</para>
        /// </remarks>
        /// <param name="script">
        /// <para>The script to run.</para>
        /// </param>
        /// <param name="sourceContext">
        /// <para>A cookie identifying the script that can be used by debuggable script contexts.</para>
        /// </param>
        /// <param name="sourceUrl">
        /// <para>The location the script came from</para>
        /// </param>
        /// <param name="parseAttributes">
        /// <para>Attribute mask for parsing the script</para>
        /// </param>
        /// <param name="result">
        /// <para>The result of the script, if any. This parameter can be null.</para>
        /// </param>
        public static _JsErrorCode JsRun(global::System.IntPtr script, ulong sourceContext, global::System.IntPtr sourceUrl, _JsParseScriptAttributes parseAttributes, out global::System.IntPtr result)
        {
            global::System.IntPtr _result;
            var __arg4 = &_result;
            var __ret = __Internal.JsRun_0(script, sourceContext, sourceUrl, parseAttributes, __arg4);
            result = _result;
            return __ret;
        }

        /// <summary>
        /// <para>Creates the property ID associated with the name.</para>
        /// </summary>
        /// <remarks>
        /// <para>Property IDs are specific to a context and cannot be used across contexts.</para>
        /// <para></para>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="name">
        /// <para>The name of the property ID to get or create. The name may consist of only digits. The string is expected to be ASCII / utf8 encoded.</para>
        /// </param>
        /// <param name="length">
        /// <para>length of the name in bytes</para>
        /// </param>
        /// <param name="propertyId">
        /// <para>The property ID in this runtime for the given name.</para>
        /// </param>
        public static _JsErrorCode JsCreatePropertyId(string name, ulong length, out global::System.IntPtr propertyId)
        {
            global::System.IntPtr _propertyId;
            var __arg2 = &_propertyId;
            var __ret = __Internal.JsCreatePropertyId_0(name, length, __arg2);
            propertyId = _propertyId;
            return __ret;
        }

        /// <summary>
        /// <para>Copies the name associated with the property ID into a buffer.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// <para></para>
        /// <para>When size of the `buffer` is unknown,</para>
        /// <para>`buffer` argument can be nullptr.</para>
        /// <para>`length` argument will return the size needed.</para>
        /// </remarks>
        /// <param name="propertyId">
        /// <para>The property ID to get the name of.</para>
        /// </param>
        /// <param name="buffer">
        /// <para>The buffer holding the name associated with the property ID, encoded as utf8</para>
        /// </param>
        /// <param name="bufferSize">
        /// <para>Size of the buffer.</para>
        /// </param>
        /// <param name="written">
        /// <para>Total number of characters written or to be written</para>
        /// </param>
        public static _JsErrorCode JsCopyPropertyId(global::System.IntPtr propertyId, sbyte* buffer, ulong bufferSize, out uint length)
        {
            fixed (uint* __refParamPtr3 = &length)
            {
                var __arg3 = __refParamPtr3;
                var __ret = __Internal.JsCopyPropertyId_0(propertyId, buffer, bufferSize, __arg3);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Serializes a parsed script to a buffer than can be reused.</para>
        /// </summary>
        /// <remarks>
        /// <para>JsSerializeScript parses a script and then stores the parsed form of the script in a</para>
        /// <para>runtime-independent format. The serialized script then can be deserialized in any</para>
        /// <para>runtime without requiring the script to be re-parsed.</para>
        /// <para></para>
        /// <para>Requires an active script context.</para>
        /// <para></para>
        /// <para>Script source can be either JavascriptString or JavascriptExternalArrayBuffer.</para>
        /// <para>In case it is an ExternalArrayBuffer, and the encoding of the buffer is Utf16,</para>
        /// <para>JsParseScriptAttributeArrayBufferIsUtf16Encoded is expected on parseAttributes.</para>
        /// <para></para>
        /// <para>Use JavascriptExternalArrayBuffer with Utf8/ASCII script source</para>
        /// <para>for better performance and smaller memory footprint.</para>
        /// </remarks>
        /// <param name="script">
        /// <para>The script to serialize</para>
        /// </param>
        /// <param name="buffer">
        /// <para>ArrayBuffer</para>
        /// </param>
        /// <param name="parseAttributes">
        /// <para>Encoding for the script.</para>
        /// </param>
        public static _JsErrorCode JsSerialize(global::System.IntPtr script, out global::System.IntPtr buffer, _JsParseScriptAttributes parseAttributes)
        {
            global::System.IntPtr _buffer;
            var __arg1 = &_buffer;
            var __ret = __Internal.JsSerialize_0(script, __arg1, parseAttributes);
            buffer = _buffer;
            return __ret;
        }

        /// <summary>
        /// <para>Parses a serialized script and returns a function representing the script.     Provides the ability to lazy load the script source only if/when it is needed.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="buffer">
        /// <para>The serialized script as an ArrayBuffer (preferably ExternalArrayBuffer).</para>
        /// </param>
        /// <param name="scriptLoadCallback">
        /// <para>Callback called when the source code of the script needs to be loaded. This is an optional parameter, set to null if not needed.</para>
        /// </param>
        /// <param name="sourceContext">
        /// <para>A cookie identifying the script that can be used by debuggable script contexts. This context will passed into scriptLoadCallback.</para>
        /// </param>
        /// <param name="sourceUrl">
        /// <para>The location the script came from.</para>
        /// </param>
        /// <param name="result">
        /// <para>A function representing the script code.</para>
        /// </param>
        public static _JsErrorCode JsParseSerialized(global::System.IntPtr buffer, JsSerializedLoadScriptCallback scriptLoadCallback, ulong sourceContext, global::System.IntPtr sourceUrl, out global::System.IntPtr result)
        {
            var __arg1 = scriptLoadCallback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(scriptLoadCallback);
            global::System.IntPtr _result;
            var __arg4 = &_result;
            var __ret = __Internal.JsParseSerialized_0(buffer, __arg1, sourceContext, sourceUrl, __arg4);
            result = _result;
            return __ret;
        }

        /// <summary>
        /// <para>Runs a serialized script.     Provides the ability to lazy load the script source only if/when it is needed.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// <para></para>
        /// <para>The runtime will hold on to the buffer until all instances of any functions created from</para>
        /// <para>the buffer are garbage collected.</para>
        /// </remarks>
        /// <param name="buffer">
        /// <para>The serialized script as an ArrayBuffer (preferably ExternalArrayBuffer).</para>
        /// </param>
        /// <param name="scriptLoadCallback">
        /// <para>Callback called when the source code of the script needs to be loaded.</para>
        /// </param>
        /// <param name="sourceContext">
        /// <para>A cookie identifying the script that can be used by debuggable script contexts. This context will passed into scriptLoadCallback.</para>
        /// </param>
        /// <param name="sourceUrl">
        /// <para>The location the script came from.</para>
        /// </param>
        /// <param name="result">
        /// <para>The result of running the script, if any. This parameter can be null.</para>
        /// </param>
        public static _JsErrorCode JsRunSerialized(global::System.IntPtr buffer, JsSerializedLoadScriptCallback scriptLoadCallback, ulong sourceContext, global::System.IntPtr sourceUrl, out global::System.IntPtr result)
        {
            var __arg1 = scriptLoadCallback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(scriptLoadCallback);
            global::System.IntPtr _result;
            var __arg4 = &_result;
            var __ret = __Internal.JsRunSerialized_0(buffer, __arg1, sourceContext, sourceUrl, __arg4);
            result = _result;
            return __ret;
        }
    }

    /// <summary>
    /// <para>An error code returned from a Chakra hosting API.</para>
    /// </summary>
    public enum _JsErrorCode
    {
        /// <summary>Success error code.</summary>
        JsNoError = 0,
        /// <summary>Category of errors that relates to incorrect usage of the API itself.</summary>
        JsErrorCategoryUsage = 65536,
        /// <summary>An argument to a hosting API was invalid.</summary>
        JsErrorInvalidArgument = 65537,
        /// <summary>An argument to a hosting API was null in a context where null is not allowed.</summary>
        JsErrorNullArgument = 65538,
        /// <summary>The hosting API requires that a context be current, but there is no current context.</summary>
        JsErrorNoCurrentContext = 65539,
        /// <summary>The engine is in an exception state and no APIs can be called until the exception is cleared.</summary>
        JsErrorInExceptionState = 65540,
        /// <summary>A hosting API is not yet implemented.</summary>
        JsErrorNotImplemented = 65541,
        /// <summary>A hosting API was called on the wrong thread.</summary>
        JsErrorWrongThread = 65542,
        /// <summary>A runtime that is still in use cannot be disposed.</summary>
        JsErrorRuntimeInUse = 65543,
        /// <summary>A bad serialized script was used, or the serialized script was serialized by a different version of the Chakra engine.</summary>
        JsErrorBadSerializedScript = 65544,
        /// <summary>The runtime is in a disabled state.</summary>
        JsErrorInDisabledState = 65545,
        /// <summary>Runtime does not support reliable script interruption.</summary>
        JsErrorCannotDisableExecution = 65546,
        /// <summary>A heap enumeration is currently underway in the script context.</summary>
        JsErrorHeapEnumInProgress = 65547,
        /// <summary>A hosting API that operates on object values was called with a non-object value.</summary>
        JsErrorArgumentNotObject = 65548,
        /// <summary>A script context is in the middle of a profile callback.</summary>
        JsErrorInProfileCallback = 65549,
        /// <summary>A thread service callback is currently underway.</summary>
        JsErrorInThreadServiceCallback = 65550,
        /// <summary>Scripts cannot be serialized in debug contexts.</summary>
        JsErrorCannotSerializeDebugScript = 65551,
        /// <summary>The context cannot be put into a debug state because it is already in a debug state.</summary>
        JsErrorAlreadyDebuggingContext = 65552,
        /// <summary>The context cannot start profiling because it is already profiling.</summary>
        JsErrorAlreadyProfilingContext = 65553,
        /// <summary>Idle notification given when the host did not enable idle processing.</summary>
        JsErrorIdleNotEnabled = 65554,
        /// <summary>The context did not accept the enqueue callback.</summary>
        JsCannotSetProjectionEnqueueCallback = 65555,
        /// <summary>Failed to start projection.</summary>
        JsErrorCannotStartProjection = 65556,
        /// <summary>The operation is not supported in an object before collect callback.</summary>
        JsErrorInObjectBeforeCollectCallback = 65557,
        /// <summary>Object cannot be unwrapped to IInspectable pointer.</summary>
        JsErrorObjectNotInspectable = 65558,
        /// <summary>A hosting API that operates on symbol property ids but was called with a non-symbol property id. The error code is returned by JsGetSymbolFromPropertyId if the function is called with non-symbol property id.</summary>
        JsErrorPropertyNotSymbol = 65559,
        /// <summary>A hosting API that operates on string property ids but was called with a non-string property id. The error code is returned by existing JsGetPropertyNamefromId if the function is called with non-string property id.</summary>
        JsErrorPropertyNotString = 65560,
        /// <summary>Module evaulation is called in wrong context.</summary>
        JsErrorInvalidContext = 65561,
        /// <summary>Module evaulation is called in wrong context.</summary>
        JsInvalidModuleHostInfoKind = 65562,
        /// <summary>Module was parsed already when JsParseModuleSource is called.</summary>
        JsErrorModuleParsed = 65563,
        /// <summary>Module was evaluated already when JsModuleEvaluation is called.</summary>
        JsErrorModuleEvaluated = 65564,
        /// <summary>Category of errors that relates to errors occurring within the engine itself.</summary>
        JsErrorCategoryEngine = 131072,
        /// <summary>The Chakra engine has run out of memory.</summary>
        JsErrorOutOfMemory = 131073,
        /// <summary>The Chakra engine failed to set the Floating Point Unit state.</summary>
        JsErrorBadFPUState = 131074,
        /// <summary>Category of errors that relates to errors in a script.</summary>
        JsErrorCategoryScript = 196608,
        /// <summary>A JavaScript exception occurred while running a script.</summary>
        JsErrorScriptException = 196609,
        /// <summary>JavaScript failed to compile.</summary>
        JsErrorScriptCompile = 196610,
        /// <summary>A script was terminated due to a request to suspend a runtime.</summary>
        JsErrorScriptTerminated = 196611,
        /// <summary>A script was terminated because it tried to use <c>eval</c> or <c>function</c> and eval was disabled.</summary>
        JsErrorScriptEvalDisabled = 196612,
        /// <summary>Category of errors that are fatal and signify failure of the engine.</summary>
        JsErrorCategoryFatal = 262144,
        /// <summary>A fatal error in the engine has occurred.</summary>
        JsErrorFatal = 262145,
        /// <summary>A hosting API was called with object created on different javascript runtime.</summary>
        JsErrorWrongRuntime = 262146,
        /// <summary>Category of errors that are related to failures during diagnostic operations.</summary>
        JsErrorCategoryDiagError = 327680,
        /// <summary>The object for which the debugging API was called was not found</summary>
        JsErrorDiagAlreadyInDebugMode = 327681,
        /// <summary>The debugging API can only be called when VM is in debug mode</summary>
        JsErrorDiagNotInDebugMode = 327682,
        /// <summary>The debugging API can only be called when VM is at a break</summary>
        JsErrorDiagNotAtBreak = 327683,
        /// <summary>Debugging API was called with an invalid handle.</summary>
        JsErrorDiagInvalidHandle = 327684,
        /// <summary>The object for which the debugging API was called was not found</summary>
        JsErrorDiagObjectNotFound = 327685,
        /// <summary>VM was unable to perfom the request action</summary>
        JsErrorDiagUnableToPerformAction = 327686
    }

    /// <summary>
    /// <para>Attributes of a runtime.</para>
    /// </summary>
    [Flags]
    public enum _JsRuntimeAttributes
    {
        /// <summary>No special attributes.</summary>
        JsRuntimeAttributeNone = 0,
        /// <summary>The runtime will not do any work (such as garbage collection) on background threads.</summary>
        JsRuntimeAttributeDisableBackgroundWork = 1,
        /// <summary>The runtime should support reliable script interruption. This increases the number of places where the runtime will check for a script interrupt request at the cost of a small amount of runtime performance.</summary>
        JsRuntimeAttributeAllowScriptInterrupt = 2,
        /// <summary>Host will call <c>JsIdle</c>, so enable idle processing. Otherwise, the runtime will manage memory slightly more aggressively.</summary>
        JsRuntimeAttributeEnableIdleProcessing = 4,
        /// <summary>Runtime will not generate native code.</summary>
        JsRuntimeAttributeDisableNativeCodeGeneration = 8,
        /// <summary>Using <c>eval</c> or <c>function</c> constructor will throw an exception.</summary>
        JsRuntimeAttributeDisableEval = 16,
        /// <summary>Runtime will enable all experimental features.</summary>
        JsRuntimeAttributeEnableExperimentalFeatures = 32,
        /// <summary>Calling <c>JsSetException</c> will also dispatch the exception to the script debugger (if any) giving the debugger a chance to break on the exception.</summary>
        JsRuntimeAttributeDispatchSetExceptionsToDebugger = 64
    }

    /// <summary>
    /// <para>The type of a typed JavaScript array.</para>
    /// </summary>
    public enum _JsTypedArrayType
    {
        /// <summary>An int8 array.</summary>
        JsArrayTypeInt8 = 0,
        /// <summary>An uint8 array.</summary>
        JsArrayTypeUint8 = 1,
        /// <summary>An uint8 clamped array.</summary>
        JsArrayTypeUint8Clamped = 2,
        /// <summary>An int16 array.</summary>
        JsArrayTypeInt16 = 3,
        /// <summary>An uint16 array.</summary>
        JsArrayTypeUint16 = 4,
        /// <summary>An int32 array.</summary>
        JsArrayTypeInt32 = 5,
        /// <summary>An uint32 array.</summary>
        JsArrayTypeUint32 = 6,
        /// <summary>A float32 array.</summary>
        JsArrayTypeFloat32 = 7,
        /// <summary>A float64 array.</summary>
        JsArrayTypeFloat64 = 8
    }

    /// <summary>
    /// <para>Allocation callback event type.</para>
    /// </summary>
    public enum _JsMemoryEventType
    {
        /// <summary>Indicates a request for memory allocation.</summary>
        JsMemoryAllocate = 0,
        /// <summary>Indicates a memory freeing event.</summary>
        JsMemoryFree = 1,
        /// <summary>Indicates a failed allocation event.</summary>
        JsMemoryFailure = 2
    }

    /// <summary>
    /// <para>Attribute mask for JsParseScriptWithAttributes</para>
    /// </summary>
    public enum _JsParseScriptAttributes
    {
        /// <summary>Default attribute</summary>
        JsParseScriptAttributeNone = 0,
        /// <summary>Specified script is internal and non-user code. Hidden from debugger</summary>
        JsParseScriptAttributeLibraryCode = 1,
        /// <summary>ChakraCore assumes ExternalArrayBuffer is Utf8 by default. This one needs to be set for Utf16</summary>
        JsParseScriptAttributeArrayBufferIsUtf16Encoded = 2
    }

    /// <summary>
    /// <para>Type enumeration of a JavaScript property</para>
    /// </summary>
    public enum _JsPropertyIdType
    {
        /// <summary>Type enumeration of a JavaScript string property</summary>
        JsPropertyIdTypeString = 0,
        /// <summary>Type enumeration of a JavaScript symbol property</summary>
        JsPropertyIdTypeSymbol = 1
    }

    /// <summary>
    /// <para>The JavaScript type of a JsValueRef.</para>
    /// </summary>
    public enum _JsValueType
    {
        /// <summary>The value is the <c>undefined</c> value.</summary>
        JsUndefined = 0,
        /// <summary>The value is the <c>null</c> value.</summary>
        JsNull = 1,
        /// <summary>The value is a JavaScript number value.</summary>
        JsNumber = 2,
        /// <summary>The value is a JavaScript string value.</summary>
        JsString = 3,
        /// <summary>The value is a JavaScript Boolean value.</summary>
        JsBoolean = 4,
        /// <summary>The value is a JavaScript object value.</summary>
        JsObject = 5,
        /// <summary>The value is a JavaScript function object value.</summary>
        JsFunction = 6,
        /// <summary>The value is a JavaScript error object value.</summary>
        JsError = 7,
        /// <summary>The value is a JavaScript array object value.</summary>
        JsArray = 8,
        /// <summary>The value is a JavaScript symbol value.</summary>
        JsSymbol = 9,
        /// <summary>The value is a JavaScript ArrayBuffer object value.</summary>
        JsArrayBuffer = 10,
        /// <summary>The value is a JavaScript typed array object value.</summary>
        JsTypedArray = 11,
        /// <summary>The value is a JavaScript DataView object value.</summary>
        JsDataView = 12
    }

    public class HANDLE { }

    /// <summary>
    /// <para>A handle to a Chakra runtime.</para>
    /// </summary>
    /// <remarks>
    /// <para>Each Chakra runtime has its own independent execution engine, JIT compiler, and garbage</para>
    /// <para>collected heap. As such, each runtime is completely isolated from other runtimes.</para>
    /// <para></para>
    /// <para>Runtimes can be used on any thread, but only one thread can call into a runtime at any</para>
    /// <para>time.</para>
    /// <para></para>
    /// <para>NOTE: A JsRuntimeHandle, unlike other object references in the Chakra hosting API,</para>
    /// <para>is not garbage collected since it contains the garbage collected heap itself. A runtime</para>
    /// <para>will continue to exist until JsDisposeRuntime is called.</para>
    /// </remarks>
    public class JsRuntimeHandle { }

    /// <summary>
    /// <para>A reference to an object owned by the Chakra garbage collector.</para>
    /// </summary>
    /// <remarks>
    /// <para>A Chakra runtime will automatically track JsRef references as long as they are</para>
    /// <para>stored in local variables or in parameters (i.e. on the stack). Storing a JsRef</para>
    /// <para>somewhere other than on the stack requires calling JsAddRef and JsRelease to</para>
    /// <para>manage the lifetime of the object, otherwise the garbage collector may free the object</para>
    /// <para>while it is still in use.</para>
    /// </remarks>
    public class JsRef { }

    /// <summary>
    /// <para>A reference to a script context.</para>
    /// </summary>
    /// <remarks>
    /// <para>Each script context contains its own global object, distinct from the global object in</para>
    /// <para>other script contexts.</para>
    /// <para></para>
    /// <para>Many Chakra hosting APIs require an &quot;active&quot; script context, which can be set using</para>
    /// <para>JsSetCurrentContext. Chakra hosting APIs that require a current context to be set</para>
    /// <para>will note that explicitly in their documentation.</para>
    /// </remarks>
    /// <summary>
    /// <para>A reference to a JavaScript value.</para>
    /// </summary>
    /// <remarks>
    /// <para>A JavaScript value is one of the following types of values: undefined, null, Boolean,</para>
    /// <para>string, number, or object.</para>
    /// </remarks>
    /// <summary>
    /// <para>A cookie that identifies a script for debugging purposes.</para>
    /// </summary>
    /// <summary>
    /// <para>A property identifier.</para>
    /// </summary>
    /// <remarks>
    /// <para>Property identifiers are used to refer to properties of JavaScript objects instead of using</para>
    /// <para>strings.</para>
    /// </remarks>
    /// <summary>
    /// <para>User implemented callback routine for memory allocation events</para>
    /// </summary>
    /// <remarks>
    /// <para>Use JsSetRuntimeMemoryAllocationCallback to register this callback.</para>
    /// </remarks>
    /// <param name="callbackState">
    /// <para>The state passed to JsSetRuntimeMemoryAllocationCallback.</para>
    /// </param>
    /// <param name="allocationEvent">
    /// <para>The type of type allocation event.</para>
    /// </param>
    /// <param name="allocationSize">
    /// <para>The size of the allocation.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate bool JsMemoryAllocationCallback(global::System.IntPtr callbackState, _JsMemoryEventType allocationEvent, ulong allocationSize);

    /// <summary>
    /// <para>A callback called before collection.</para>
    /// </summary>
    /// <remarks>
    /// <para>Use JsSetBeforeCollectCallback to register this callback.</para>
    /// </remarks>
    /// <param name="callbackState">
    /// <para>The state passed to JsSetBeforeCollectCallback.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void JsBeforeCollectCallback(global::System.IntPtr callbackState);

    /// <summary>
    /// <para>A callback called before collecting an object.</para>
    /// </summary>
    /// <remarks>
    /// <para>Use JsSetObjectBeforeCollectCallback to register this callback.</para>
    /// </remarks>
    /// <param name="ref">
    /// <para>The object to be collected.</para>
    /// </param>
    /// <param name="callbackState">
    /// <para>The state passed to JsSetObjectBeforeCollectCallback.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void JsObjectBeforeCollectCallback(global::System.IntPtr @ref, global::System.IntPtr callbackState);

    /// <summary>
    /// <para>A background work item callback.</para>
    /// </summary>
    /// <remarks>
    /// <para>This is passed to the host's thread service (if provided) to allow the host to</para>
    /// <para>invoke the work item callback on the background thread of its choice.</para>
    /// </remarks>
    /// <param name="callbackState">
    /// <para>Data argument passed to the thread service.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void JsBackgroundWorkItemCallback(global::System.IntPtr callbackState);

    /// <summary>
    /// <para>A thread service callback.</para>
    /// </summary>
    /// <remarks>
    /// <para>The host can specify a background thread service when calling JsCreateRuntime. If</para>
    /// <para>specified, then background work items will be passed to the host using this callback. The</para>
    /// <para>host is expected to either begin executing the background work item immediately and return</para>
    /// <para>true or return false and the runtime will handle the work item in-thread.</para>
    /// </remarks>
    /// <param name="callback">
    /// <para>The callback for the background work item.</para>
    /// </param>
    /// <param name="callbackState">
    /// <para>The data argument to be passed to the callback.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate bool JsThreadServiceCallback(global::System.IntPtr callback, global::System.IntPtr callbackState);

    /// <summary>
    /// <para>Called by the runtime when it is finished with all resources related to the script execution.     The caller should free the source if loaded, the byte code, and the context at this time.</para>
    /// </summary>
    /// <param name="sourceContext">
    /// <para>The context passed to Js[Parse|Run]SerializedScriptWithCallback</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void JsSerializedScriptUnloadCallback(ulong sourceContext);

    /// <summary>
    /// <para>A finalizer callback.</para>
    /// </summary>
    /// <param name="data">
    /// <para>The external data that was passed in when creating the object being finalized.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void JsFinalizeCallback(global::System.IntPtr data);

    /// <summary>
    /// <para>A function callback.</para>
    /// </summary>
    /// <param name="callee">
    /// <para>A function object that represents the function being invoked.</para>
    /// </param>
    /// <param name="isConstructCall">
    /// <para>Indicates whether this is a regular call or a 'new' call.</para>
    /// </param>
    /// <param name="arguments">
    /// <para>The arguments to the call.</para>
    /// </param>
    /// <param name="argumentCount">
    /// <para>The number of arguments.</para>
    /// </param>
    /// <param name="callbackState">
    /// <para>The state passed to JsCreateFunction.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::System.IntPtr JsNativeFunction(global::System.IntPtr callee, bool isConstructCall, global::System.IntPtr arguments, ushort argumentCount, global::System.IntPtr callbackState);

    /// <summary>
    /// <para>A promise continuation callback.</para>
    /// </summary>
    /// <remarks>
    /// <para>The host can specify a promise continuation callback in JsSetPromiseContinuationCallback. If</para>
    /// <para>a script creates a task to be run later, then the promise continuation callback will be called with</para>
    /// <para>the task and the task should be put in a FIFO queue, to be run when the current script is</para>
    /// <para>done executing.</para>
    /// </remarks>
    /// <param name="task">
    /// <para>The task, represented as a JavaScript function.</para>
    /// </param>
    /// <param name="callbackState">
    /// <para>The data argument to be passed to the callback.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void JsPromiseContinuationCallback(global::System.IntPtr task, global::System.IntPtr callbackState);

    public unsafe partial class ChakraCommon
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateRuntime")]
            internal static extern _JsErrorCode JsCreateRuntime_0(_JsRuntimeAttributes attributes, global::System.IntPtr threadService, global::System.IntPtr* runtime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCollectGarbage")]
            internal static extern _JsErrorCode JsCollectGarbage_0(global::System.IntPtr runtime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDisposeRuntime")]
            internal static extern _JsErrorCode JsDisposeRuntime_0(global::System.IntPtr runtime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetRuntimeMemoryUsage")]
            internal static extern _JsErrorCode JsGetRuntimeMemoryUsage_0(global::System.IntPtr runtime, uint* memoryUsage);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetRuntimeMemoryLimit")]
            internal static extern _JsErrorCode JsGetRuntimeMemoryLimit_0(global::System.IntPtr runtime, uint* memoryLimit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSetRuntimeMemoryLimit")]
            internal static extern _JsErrorCode JsSetRuntimeMemoryLimit_0(global::System.IntPtr runtime, ulong memoryLimit);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSetRuntimeMemoryAllocationCallback")]
            internal static extern _JsErrorCode JsSetRuntimeMemoryAllocationCallback_0(global::System.IntPtr runtime, global::System.IntPtr callbackState, global::System.IntPtr allocationCallback);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSetRuntimeBeforeCollectCallback")]
            internal static extern _JsErrorCode JsSetRuntimeBeforeCollectCallback_0(global::System.IntPtr runtime, global::System.IntPtr callbackState, global::System.IntPtr beforeCollectCallback);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsAddRef")]
            internal static extern _JsErrorCode JsAddRef_0(global::System.IntPtr @ref, uint* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsRelease")]
            internal static extern _JsErrorCode JsRelease_0(global::System.IntPtr @ref, uint* count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSetObjectBeforeCollectCallback")]
            internal static extern _JsErrorCode JsSetObjectBeforeCollectCallback_0(global::System.IntPtr @ref, global::System.IntPtr callbackState, global::System.IntPtr objectBeforeCollectCallback);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateContext")]
            internal static extern _JsErrorCode JsCreateContext_0(global::System.IntPtr runtime, global::System.IntPtr* newContext);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetCurrentContext")]
            internal static extern _JsErrorCode JsGetCurrentContext_0(global::System.IntPtr* currentContext);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSetCurrentContext")]
            internal static extern _JsErrorCode JsSetCurrentContext_0(global::System.IntPtr context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetContextOfObject")]
            internal static extern _JsErrorCode JsGetContextOfObject_0(global::System.IntPtr targetObject, global::System.IntPtr* context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetContextData")]
            internal static extern _JsErrorCode JsGetContextData_0(global::System.IntPtr context, global::System.IntPtr* data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSetContextData")]
            internal static extern _JsErrorCode JsSetContextData_0(global::System.IntPtr context, global::System.IntPtr data);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetRuntime")]
            internal static extern _JsErrorCode JsGetRuntime_0(global::System.IntPtr context, global::System.IntPtr* runtime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsIdle")]
            internal static extern _JsErrorCode JsIdle_0(uint* nextIdleTick);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetSymbolFromPropertyId")]
            internal static extern _JsErrorCode JsGetSymbolFromPropertyId_0(global::System.IntPtr propertyId, global::System.IntPtr* symbol);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetPropertyIdType")]
            internal static extern _JsErrorCode JsGetPropertyIdType_0(global::System.IntPtr propertyId, _JsPropertyIdType* propertyIdType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetPropertyIdFromSymbol")]
            internal static extern _JsErrorCode JsGetPropertyIdFromSymbol_0(global::System.IntPtr symbol, global::System.IntPtr* propertyId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateSymbol")]
            internal static extern _JsErrorCode JsCreateSymbol_0(global::System.IntPtr description, global::System.IntPtr* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetOwnPropertySymbols")]
            internal static extern _JsErrorCode JsGetOwnPropertySymbols_0(global::System.IntPtr targetObject, global::System.IntPtr* propertySymbols);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetUndefinedValue")]
            internal static extern _JsErrorCode JsGetUndefinedValue_0(global::System.IntPtr* undefinedValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetNullValue")]
            internal static extern _JsErrorCode JsGetNullValue_0(global::System.IntPtr* nullValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetTrueValue")]
            internal static extern _JsErrorCode JsGetTrueValue_0(global::System.IntPtr* trueValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetFalseValue")]
            internal static extern _JsErrorCode JsGetFalseValue_0(global::System.IntPtr* falseValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsBoolToBoolean")]
            internal static extern _JsErrorCode JsBoolToBoolean_0(bool value, global::System.IntPtr* booleanValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsBooleanToBool")]
            internal static extern _JsErrorCode JsBooleanToBool_0(global::System.IntPtr value, bool* boolValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsConvertValueToBoolean")]
            internal static extern _JsErrorCode JsConvertValueToBoolean_0(global::System.IntPtr value, global::System.IntPtr* booleanValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetValueType")]
            internal static extern _JsErrorCode JsGetValueType_0(global::System.IntPtr value, _JsValueType* type);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDoubleToNumber")]
            internal static extern _JsErrorCode JsDoubleToNumber_0(double doubleValue, global::System.IntPtr* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsIntToNumber")]
            internal static extern _JsErrorCode JsIntToNumber_0(int intValue, global::System.IntPtr* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsNumberToDouble")]
            internal static extern _JsErrorCode JsNumberToDouble_0(global::System.IntPtr value, double* doubleValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsNumberToInt")]
            internal static extern _JsErrorCode JsNumberToInt_0(global::System.IntPtr value, int* intValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsConvertValueToNumber")]
            internal static extern _JsErrorCode JsConvertValueToNumber_0(global::System.IntPtr value, global::System.IntPtr* numberValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetStringLength")]
            internal static extern _JsErrorCode JsGetStringLength_0(global::System.IntPtr stringValue, int* length);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsConvertValueToString")]
            internal static extern _JsErrorCode JsConvertValueToString_0(global::System.IntPtr value, global::System.IntPtr* stringValue);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetGlobalObject")]
            internal static extern _JsErrorCode JsGetGlobalObject_0(global::System.IntPtr* globalObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateObject")]
            internal static extern _JsErrorCode JsCreateObject_0(global::System.IntPtr* targetObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateExternalObject")]
            internal static extern _JsErrorCode JsCreateExternalObject_0(global::System.IntPtr data, global::System.IntPtr finalizeCallback, global::System.IntPtr* targetObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsConvertValueToObject")]
            internal static extern _JsErrorCode JsConvertValueToObject_0(global::System.IntPtr value, global::System.IntPtr* targetObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetPrototype")]
            internal static extern _JsErrorCode JsGetPrototype_0(global::System.IntPtr targetObject, global::System.IntPtr* prototypeObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSetPrototype")]
            internal static extern _JsErrorCode JsSetPrototype_0(global::System.IntPtr targetObject, global::System.IntPtr prototypeObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsInstanceOf")]
            internal static extern _JsErrorCode JsInstanceOf_0(global::System.IntPtr targetObject, global::System.IntPtr constructor, bool* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetExtensionAllowed")]
            internal static extern _JsErrorCode JsGetExtensionAllowed_0(global::System.IntPtr targetObject, bool* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsPreventExtension")]
            internal static extern _JsErrorCode JsPreventExtension_0(global::System.IntPtr targetObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetProperty")]
            internal static extern _JsErrorCode JsGetProperty_0(global::System.IntPtr targetObject, global::System.IntPtr propertyId, global::System.IntPtr* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetOwnPropertyDescriptor")]
            internal static extern _JsErrorCode JsGetOwnPropertyDescriptor_0(global::System.IntPtr targetObject, global::System.IntPtr propertyId, global::System.IntPtr* propertyDescriptor);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetOwnPropertyNames")]
            internal static extern _JsErrorCode JsGetOwnPropertyNames_0(global::System.IntPtr targetObject, global::System.IntPtr* propertyNames);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSetProperty")]
            internal static extern _JsErrorCode JsSetProperty_0(global::System.IntPtr targetObject, global::System.IntPtr propertyId, global::System.IntPtr value, bool useStrictRules);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsHasProperty")]
            internal static extern _JsErrorCode JsHasProperty_0(global::System.IntPtr targetObject, global::System.IntPtr propertyId, bool* hasProperty);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDeleteProperty")]
            internal static extern _JsErrorCode JsDeleteProperty_0(global::System.IntPtr targetObject, global::System.IntPtr propertyId, bool useStrictRules, global::System.IntPtr* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDefineProperty")]
            internal static extern _JsErrorCode JsDefineProperty_0(global::System.IntPtr targetObject, global::System.IntPtr propertyId, global::System.IntPtr propertyDescriptor, bool* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsHasIndexedProperty")]
            internal static extern _JsErrorCode JsHasIndexedProperty_0(global::System.IntPtr targetObject, global::System.IntPtr index, bool* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetIndexedProperty")]
            internal static extern _JsErrorCode JsGetIndexedProperty_0(global::System.IntPtr targetObject, global::System.IntPtr index, global::System.IntPtr* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSetIndexedProperty")]
            internal static extern _JsErrorCode JsSetIndexedProperty_0(global::System.IntPtr targetObject, global::System.IntPtr index, global::System.IntPtr value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDeleteIndexedProperty")]
            internal static extern _JsErrorCode JsDeleteIndexedProperty_0(global::System.IntPtr targetObject, global::System.IntPtr index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsHasIndexedPropertiesExternalData")]
            internal static extern _JsErrorCode JsHasIndexedPropertiesExternalData_0(global::System.IntPtr targetObject, bool* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetIndexedPropertiesExternalData")]
            internal static extern _JsErrorCode JsGetIndexedPropertiesExternalData_0(global::System.IntPtr targetObject, global::System.IntPtr* data, _JsTypedArrayType* arrayType, uint* elementLength);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSetIndexedPropertiesToExternalData")]
            internal static extern _JsErrorCode JsSetIndexedPropertiesToExternalData_0(global::System.IntPtr targetObject, global::System.IntPtr data, _JsTypedArrayType arrayType, uint elementLength);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsEquals")]
            internal static extern _JsErrorCode JsEquals_0(global::System.IntPtr object1, global::System.IntPtr object2, bool* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsStrictEquals")]
            internal static extern _JsErrorCode JsStrictEquals_0(global::System.IntPtr object1, global::System.IntPtr object2, bool* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsHasExternalData")]
            internal static extern _JsErrorCode JsHasExternalData_0(global::System.IntPtr targetObject, bool* value);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetExternalData")]
            internal static extern _JsErrorCode JsGetExternalData_0(global::System.IntPtr targetObject, global::System.IntPtr* externalData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSetExternalData")]
            internal static extern _JsErrorCode JsSetExternalData_0(global::System.IntPtr targetObject, global::System.IntPtr externalData);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateArray")]
            internal static extern _JsErrorCode JsCreateArray_0(uint length, global::System.IntPtr* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateArrayBuffer")]
            internal static extern _JsErrorCode JsCreateArrayBuffer_0(uint byteLength, global::System.IntPtr* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateExternalArrayBuffer")]
            internal static extern _JsErrorCode JsCreateExternalArrayBuffer_0(global::System.IntPtr data, uint byteLength, global::System.IntPtr finalizeCallback, global::System.IntPtr callbackState, global::System.IntPtr* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateTypedArray")]
            internal static extern _JsErrorCode JsCreateTypedArray_0(_JsTypedArrayType arrayType, global::System.IntPtr baseArray, uint byteOffset, uint elementLength, global::System.IntPtr* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateDataView")]
            internal static extern _JsErrorCode JsCreateDataView_0(global::System.IntPtr arrayBuffer, uint byteOffset, uint byteLength, global::System.IntPtr* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetTypedArrayInfo")]
            internal static extern _JsErrorCode JsGetTypedArrayInfo_0(global::System.IntPtr typedArray, _JsTypedArrayType* arrayType, global::System.IntPtr* arrayBuffer, uint* byteOffset, uint* byteLength);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetArrayBufferStorage")]
            internal static extern _JsErrorCode JsGetArrayBufferStorage_0(global::System.IntPtr arrayBuffer, global::System.IntPtr* buffer, uint* bufferLength);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetTypedArrayStorage")]
            internal static extern _JsErrorCode JsGetTypedArrayStorage_0(global::System.IntPtr typedArray, global::System.IntPtr* buffer, uint* bufferLength, _JsTypedArrayType* arrayType, int* elementSize);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetDataViewStorage")]
            internal static extern _JsErrorCode JsGetDataViewStorage_0(global::System.IntPtr dataView, global::System.IntPtr* buffer, uint* bufferLength);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCallFunction")]
            internal static extern _JsErrorCode JsCallFunction_0(global::System.IntPtr function, global::System.IntPtr arguments, ushort argumentCount, global::System.IntPtr* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsConstructObject")]
            internal static extern _JsErrorCode JsConstructObject_0(global::System.IntPtr function, global::System.IntPtr arguments, ushort argumentCount, global::System.IntPtr* result);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateFunction")]
            internal static extern _JsErrorCode JsCreateFunction_0(global::System.IntPtr nativeFunction, global::System.IntPtr callbackState, global::System.IntPtr* function);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateNamedFunction")]
            internal static extern _JsErrorCode JsCreateNamedFunction_0(global::System.IntPtr name, global::System.IntPtr nativeFunction, global::System.IntPtr callbackState, global::System.IntPtr* function);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateError")]
            internal static extern _JsErrorCode JsCreateError_0(global::System.IntPtr message, global::System.IntPtr* error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateRangeError")]
            internal static extern _JsErrorCode JsCreateRangeError_0(global::System.IntPtr message, global::System.IntPtr* error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateReferenceError")]
            internal static extern _JsErrorCode JsCreateReferenceError_0(global::System.IntPtr message, global::System.IntPtr* error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateSyntaxError")]
            internal static extern _JsErrorCode JsCreateSyntaxError_0(global::System.IntPtr message, global::System.IntPtr* error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateTypeError")]
            internal static extern _JsErrorCode JsCreateTypeError_0(global::System.IntPtr message, global::System.IntPtr* error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsCreateURIError")]
            internal static extern _JsErrorCode JsCreateURIError_0(global::System.IntPtr message, global::System.IntPtr* error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsHasException")]
            internal static extern _JsErrorCode JsHasException_0(bool* hasException);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsGetAndClearException")]
            internal static extern _JsErrorCode JsGetAndClearException_0(global::System.IntPtr* exception);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSetException")]
            internal static extern _JsErrorCode JsSetException_0(global::System.IntPtr exception);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDisableRuntimeExecution")]
            internal static extern _JsErrorCode JsDisableRuntimeExecution_0(global::System.IntPtr runtime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsEnableRuntimeExecution")]
            internal static extern _JsErrorCode JsEnableRuntimeExecution_0(global::System.IntPtr runtime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsIsRuntimeExecutionDisabled")]
            internal static extern _JsErrorCode JsIsRuntimeExecutionDisabled_0(global::System.IntPtr runtime, bool* isDisabled);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsSetPromiseContinuationCallback")]
            internal static extern _JsErrorCode JsSetPromiseContinuationCallback_0(global::System.IntPtr promiseContinuationCallback, global::System.IntPtr callbackState);
        }

        /// <summary>
        /// <para>Creates a new runtime.</para>
        /// </summary>
        /// <remarks>
        /// <para>In the edge-mode binary, chakra.dll, this function lacks the runtimeVersion</para>
        /// <para>parameter (compare to jsrt9.h).</para>
        /// </remarks>
        /// <param name="attributes">
        /// <para>The attributes of the runtime to be created.</para>
        /// </param>
        /// <param name="threadService">
        /// <para>The thread service for the runtime. Can be null.</para>
        /// </param>
        /// <param name="runtime">
        /// <para>The runtime created.</para>
        /// </param>
        public static _JsErrorCode JsCreateRuntime(_JsRuntimeAttributes attributes, JsThreadServiceCallback threadService, out global::System.IntPtr runtime)
        {
            var __arg1 = threadService == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(threadService);
            global::System.IntPtr _runtime;
            var __arg2 = &_runtime;
            var __ret = __Internal.JsCreateRuntime_0(attributes, __arg1, __arg2);
            runtime = _runtime;
            return __ret;
        }

        /// <summary>
        /// <para>Performs a full garbage collection.</para>
        /// </summary>
        /// <param name="runtime">
        /// <para>The runtime in which the garbage collection will be performed.</para>
        /// </param>
        public static _JsErrorCode JsCollectGarbage(global::System.IntPtr runtime)
        {
            var __ret = __Internal.JsCollectGarbage_0(runtime);
            return __ret;
        }

        /// <summary>
        /// <para>Disposes a runtime.</para>
        /// </summary>
        /// <remarks>
        /// <para>Once a runtime has been disposed, all resources owned by it are invalid and cannot be used.</para>
        /// <para>If the runtime is active (i.e. it is set to be current on a particular thread), it cannot</para>
        /// <para>be disposed.</para>
        /// </remarks>
        /// <param name="runtime">
        /// <para>The runtime to dispose.</para>
        /// </param>
        public static _JsErrorCode JsDisposeRuntime(global::System.IntPtr runtime)
        {
            var __ret = __Internal.JsDisposeRuntime_0(runtime);
            return __ret;
        }

        /// <summary>
        /// <para>Gets the current memory usage for a runtime.</para>
        /// </summary>
        /// <remarks>
        /// <para>Memory usage can be always be retrieved, regardless of whether or not the runtime is active</para>
        /// <para>on another thread.</para>
        /// </remarks>
        /// <param name="runtime">
        /// <para>The runtime whose memory usage is to be retrieved.</para>
        /// </param>
        /// <param name="memoryUsage">
        /// <para>The runtime's current memory usage, in bytes.</para>
        /// </param>
        public static _JsErrorCode JsGetRuntimeMemoryUsage(global::System.IntPtr runtime, out uint memoryUsage)
        {
            fixed (uint* __refParamPtr1 = &memoryUsage)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.JsGetRuntimeMemoryUsage_0(runtime, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Gets the current memory limit for a runtime.</para>
        /// </summary>
        /// <remarks>
        /// <para>The memory limit of a runtime can be always be retrieved, regardless of whether or not the</para>
        /// <para>runtime is active on another thread.</para>
        /// </remarks>
        /// <param name="runtime">
        /// <para>The runtime whose memory limit is to be retrieved.</para>
        /// </param>
        /// <param name="memoryLimit">
        /// <para>The runtime's current memory limit, in bytes, or -1 if no limit has been set.</para>
        /// </param>
        public static _JsErrorCode JsGetRuntimeMemoryLimit(global::System.IntPtr runtime, out uint memoryLimit)
        {
            fixed (uint* __refParamPtr1 = &memoryLimit)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.JsGetRuntimeMemoryLimit_0(runtime, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Sets the current memory limit for a runtime.</para>
        /// </summary>
        /// <remarks>
        /// <para>A memory limit will cause any operation which exceeds the limit to fail with an &quot;out of</para>
        /// <para>memory&quot; error. Setting a runtime's memory limit to -1 means that the runtime has no memory</para>
        /// <para>limit. New runtimes  default to having no memory limit. If the new memory limit exceeds</para>
        /// <para>current usage, the call will succeed and any future allocations in this runtime will fail</para>
        /// <para>until the runtime's memory usage drops below the limit.</para>
        /// <para></para>
        /// <para>A runtime's memory limit can be always be set, regardless of whether or not the runtime is</para>
        /// <para>active on another thread.</para>
        /// </remarks>
        /// <param name="runtime">
        /// <para>The runtime whose memory limit is to be set.</para>
        /// </param>
        /// <param name="memoryLimit">
        /// <para>The new runtime memory limit, in bytes, or -1 for no memory limit.</para>
        /// </param>
        public static _JsErrorCode JsSetRuntimeMemoryLimit(global::System.IntPtr runtime, ulong memoryLimit)
        {
            var __ret = __Internal.JsSetRuntimeMemoryLimit_0(runtime, memoryLimit);
            return __ret;
        }

        /// <summary>
        /// <para>Sets a memory allocation callback for specified runtime</para>
        /// </summary>
        /// <remarks>
        /// <para>Registering a memory allocation callback will cause the runtime to call back to the host</para>
        /// <para>whenever it acquires memory from, or releases memory to, the OS. The callback routine is</para>
        /// <para>called before the runtime memory manager allocates a block of memory. The allocation will</para>
        /// <para>be rejected if the callback returns false. The runtime memory manager will also invoke the</para>
        /// <para>callback routine after freeing a block of memory, as well as after allocation failures.</para>
        /// <para></para>
        /// <para>The callback is invoked on the current runtime execution thread, therefore execution is</para>
        /// <para>blocked until the callback completes.</para>
        /// <para></para>
        /// <para>The return value of the callback is not stored; previously rejected allocations will not</para>
        /// <para>prevent the runtime from invoking the callback again later for new memory allocations.</para>
        /// </remarks>
        /// <param name="runtime">
        /// <para>The runtime for which to register the allocation callback.</para>
        /// </param>
        /// <param name="callbackState">
        /// <para>User provided state that will be passed back to the callback.</para>
        /// </param>
        /// <param name="allocationCallback">
        /// <para>Memory allocation callback to be called for memory allocation events.</para>
        /// </param>
        public static _JsErrorCode JsSetRuntimeMemoryAllocationCallback(global::System.IntPtr runtime, global::System.IntPtr callbackState, JsMemoryAllocationCallback allocationCallback)
        {
            var __arg2 = allocationCallback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(allocationCallback);
            var __ret = __Internal.JsSetRuntimeMemoryAllocationCallback_0(runtime, callbackState, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Sets a callback function that is called by the runtime before garbage collection.</para>
        /// </summary>
        /// <remarks>
        /// <para>The callback is invoked on the current runtime execution thread, therefore execution is</para>
        /// <para>blocked until the callback completes.</para>
        /// <para></para>
        /// <para>The callback can be used by hosts to prepare for garbage collection. For example, by</para>
        /// <para>releasing unnecessary references on Chakra objects.</para>
        /// </remarks>
        /// <param name="runtime">
        /// <para>The runtime for which to register the allocation callback.</para>
        /// </param>
        /// <param name="callbackState">
        /// <para>User provided state that will be passed back to the callback.</para>
        /// </param>
        /// <param name="beforeCollectCallback">
        /// <para>The callback function being set.</para>
        /// </param>
        public static _JsErrorCode JsSetRuntimeBeforeCollectCallback(global::System.IntPtr runtime, global::System.IntPtr callbackState, JsBeforeCollectCallback beforeCollectCallback)
        {
            var __arg2 = beforeCollectCallback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(beforeCollectCallback);
            var __ret = __Internal.JsSetRuntimeBeforeCollectCallback_0(runtime, callbackState, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Adds a reference to a garbage collected object.</para>
        /// </summary>
        /// <remarks>
        /// <para>This only needs to be called on JsRef handles that are not going to be stored</para>
        /// <para>somewhere on the stack. Calling JsAddRef ensures that the object the JsRef</para>
        /// <para>refers to will not be freed until JsRelease is called.</para>
        /// </remarks>
        /// <param name="ref">
        /// <para>The object to add a reference to.</para>
        /// </param>
        /// <param name="count">
        /// <para>The object's new reference count (can pass in null).</para>
        /// </param>
        public static _JsErrorCode JsAddRef(global::System.IntPtr @ref, out uint count)
        {
            fixed (uint* __refParamPtr1 = &count)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.JsAddRef_0(@ref, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Releases a reference to a garbage collected object.</para>
        /// </summary>
        /// <remarks>
        /// <para>Removes a reference to a JsRef handle that was created by JsAddRef.</para>
        /// </remarks>
        /// <param name="ref">
        /// <para>The object to add a reference to.</para>
        /// </param>
        /// <param name="count">
        /// <para>The object's new reference count (can pass in null).</para>
        /// </param>
        public static _JsErrorCode JsRelease(global::System.IntPtr @ref, out uint count)
        {
            fixed (uint* __refParamPtr1 = &count)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.JsRelease_0(@ref, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Sets a callback function that is called by the runtime before garbage collection of     an object.</para>
        /// </summary>
        /// <remarks>
        /// <para>The callback is invoked on the current runtime execution thread, therefore execution is</para>
        /// <para>blocked until the callback completes.</para>
        /// </remarks>
        /// <param name="ref">
        /// <para>The object for which to register the callback.</para>
        /// </param>
        /// <param name="callbackState">
        /// <para>User provided state that will be passed back to the callback.</para>
        /// </param>
        /// <param name="objectBeforeCollectCallback">
        /// <para>The callback function being set. Use null to clear previously registered callback.</para>
        /// </param>
        public static _JsErrorCode JsSetObjectBeforeCollectCallback(global::System.IntPtr @ref, global::System.IntPtr callbackState, JsObjectBeforeCollectCallback objectBeforeCollectCallback)
        {
            var __arg2 = objectBeforeCollectCallback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(objectBeforeCollectCallback);
            var __ret = __Internal.JsSetObjectBeforeCollectCallback_0(@ref, callbackState, __arg2);
            return __ret;
        }

        /// <summary>
        /// <para>Creates a script context for running scripts.</para>
        /// </summary>
        /// <remarks>
        /// <para>Each script context has its own global object that is isolated from all other script</para>
        /// <para>contexts.</para>
        /// </remarks>
        /// <param name="runtime">
        /// <para>The runtime the script context is being created in.</para>
        /// </param>
        /// <param name="newContext">
        /// <para>The created script context.</para>
        /// </param>
        public static _JsErrorCode JsCreateContext(global::System.IntPtr runtime, out global::System.IntPtr newContext)
        {
            global::System.IntPtr _newContext;
            var __arg1 = &_newContext;
            var __ret = __Internal.JsCreateContext_0(runtime, __arg1);
            newContext = _newContext;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the current script context on the thread.</para>
        /// </summary>
        /// <param name="currentContext">
        /// <para>The current script context on the thread, null if there is no current script context.</para>
        /// </param>
        public static _JsErrorCode JsGetCurrentContext(out global::System.IntPtr currentContext)
        {
            global::System.IntPtr _currentContext;
            var __arg0 = &_currentContext;
            var __ret = __Internal.JsGetCurrentContext_0(__arg0);
            currentContext = _currentContext;
            return __ret;
        }

        /// <summary>
        /// <para>Sets the current script context on the thread.</para>
        /// </summary>
        /// <param name="context">
        /// <para>The script context to make current.</para>
        /// </param>
        public static _JsErrorCode JsSetCurrentContext(global::System.IntPtr context)
        {
            var __ret = __Internal.JsSetCurrentContext_0(context);
            return __ret;
        }

        /// <summary>
        /// <para>Gets the script context that the object belongs to.</para>
        /// </summary>
        /// <param name="object">
        /// <para>The object to get the context from.</para>
        /// </param>
        /// <param name="context">
        /// <para>The context the object belongs to.</para>
        /// </param>
        public static _JsErrorCode JsGetContextOfObject(global::System.IntPtr targetObject, out global::System.IntPtr context)
        {
            global::System.IntPtr _context;
            var __arg1 = &_context;
            var __ret = __Internal.JsGetContextOfObject_0(targetObject, __arg1);
            context = _context;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the internal data set on JsrtContext.</para>
        /// </summary>
        /// <param name="context">
        /// <para>The context to get the data from.</para>
        /// </param>
        /// <param name="data">
        /// <para>The pointer to the data where data will be returned.</para>
        /// </param>
        public static _JsErrorCode JsGetContextData(global::System.IntPtr context, out global::System.IntPtr data)
        {
            global::System.IntPtr _data;
            var __arg1 = &_data;
            var __ret = __Internal.JsGetContextData_0(context, __arg1);
            data = _data;
            return __ret;
        }

        /// <summary>
        /// <para>Sets the internal data of JsrtContext.</para>
        /// </summary>
        /// <param name="context">
        /// <para>The context to set the data to.</para>
        /// </param>
        /// <param name="data">
        /// <para>The pointer to the data to be set.</para>
        /// </param>
        public static _JsErrorCode JsSetContextData(global::System.IntPtr context, global::System.IntPtr data)
        {
            var __ret = __Internal.JsSetContextData_0(context, data);
            return __ret;
        }

        /// <summary>
        /// <para>Gets the runtime that the context belongs to.</para>
        /// </summary>
        /// <param name="context">
        /// <para>The context to get the runtime from.</para>
        /// </param>
        /// <param name="runtime">
        /// <para>The runtime the context belongs to.</para>
        /// </param>
        public static _JsErrorCode JsGetRuntime(global::System.IntPtr context, out global::System.IntPtr runtime)
        {
            global::System.IntPtr _runtime;
            var __arg1 = &_runtime;
            var __ret = __Internal.JsGetRuntime_0(context, __arg1);
            runtime = _runtime;
            return __ret;
        }

        /// <summary>
        /// <para>Tells the runtime to do any idle processing it need to do.</para>
        /// </summary>
        /// <remarks>
        /// <para>If idle processing has been enabled for the current runtime, calling JsIdle will</para>
        /// <para>inform the current runtime that the host is idle and that the runtime can perform</para>
        /// <para>memory cleanup tasks.</para>
        /// <para>JsIdle can also return the number of system ticks until there will be more idle work</para>
        /// <para>for the runtime to do. Calling JsIdle before this number of ticks has passed will do</para>
        /// <para>no work.</para>
        /// <para></para>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="nextIdleTick">
        /// <para>The next system tick when there will be more idle work to do. Can be null. Returns the maximum number of ticks if there no upcoming idle work to do.</para>
        /// </param>
        public static _JsErrorCode JsIdle(out uint nextIdleTick)
        {
            fixed (uint* __refParamPtr0 = &nextIdleTick)
            {
                var __arg0 = __refParamPtr0;
                var __ret = __Internal.JsIdle_0(__arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Gets the symbol associated with the property ID.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="propertyId">
        /// <para>The property ID to get the symbol of.</para>
        /// </param>
        /// <param name="symbol">
        /// <para>The symbol associated with the property ID.</para>
        /// </param>
        public static _JsErrorCode JsGetSymbolFromPropertyId(global::System.IntPtr propertyId, out global::System.IntPtr symbol)
        {
            global::System.IntPtr _symbol;
            var __arg1 = &_symbol;
            var __ret = __Internal.JsGetSymbolFromPropertyId_0(propertyId, __arg1);
            symbol = _symbol;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the type of property</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="propertyId">
        /// <para>The property ID to get the type of.</para>
        /// </param>
        /// <param name="propertyIdType">
        /// <para>The JsPropertyIdType of the given property ID</para>
        /// </param>
        public static _JsErrorCode JsGetPropertyIdType(global::System.IntPtr propertyId, out _JsPropertyIdType propertyIdType)
        {
            _JsPropertyIdType _propertyIdType;
            var __arg1 = &_propertyIdType;
            var __ret = __Internal.JsGetPropertyIdType_0(propertyId, __arg1);
            propertyIdType = _propertyIdType;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the property ID associated with the symbol.</para>
        /// </summary>
        /// <remarks>
        /// <para>Property IDs are specific to a context and cannot be used across contexts.</para>
        /// <para></para>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="symbol">
        /// <para>The symbol whose property ID is being retrieved.</para>
        /// </param>
        /// <param name="propertyId">
        /// <para>The property ID for the given symbol.</para>
        /// </param>
        public static _JsErrorCode JsGetPropertyIdFromSymbol(global::System.IntPtr symbol, out global::System.IntPtr propertyId)
        {
            global::System.IntPtr _propertyId;
            var __arg1 = &_propertyId;
            var __ret = __Internal.JsGetPropertyIdFromSymbol_0(symbol, __arg1);
            propertyId = _propertyId;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a Javascript symbol.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="description">
        /// <para>The string description of the symbol. Can be null.</para>
        /// </param>
        /// <param name="result">
        /// <para>The new symbol.</para>
        /// </param>
        public static _JsErrorCode JsCreateSymbol(global::System.IntPtr description, out global::System.IntPtr result)
        {
            global::System.IntPtr _result;
            var __arg1 = &_result;
            var __ret = __Internal.JsCreateSymbol_0(description, __arg1);
            result = _result;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the list of all symbol properties on the object.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object from which to get the property symbols.</para>
        /// </param>
        /// <param name="propertySymbols">
        /// <para>An array of property symbols.</para>
        /// </param>
        public static _JsErrorCode JsGetOwnPropertySymbols(global::System.IntPtr targetObject, out global::System.IntPtr propertySymbols)
        {
            global::System.IntPtr _propertySymbols;
            var __arg1 = &_propertySymbols;
            var __ret = __Internal.JsGetOwnPropertySymbols_0(targetObject, __arg1);
            propertySymbols = _propertySymbols;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the value of undefined in the current script context.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="undefinedValue">
        /// <para>The undefined value.</para>
        /// </param>
        public static _JsErrorCode JsGetUndefinedValue(out global::System.IntPtr undefinedValue)
        {
            global::System.IntPtr _undefinedValue;
            var __arg0 = &_undefinedValue;
            var __ret = __Internal.JsGetUndefinedValue_0(__arg0);
            undefinedValue = _undefinedValue;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the value of null in the current script context.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="nullValue">
        /// <para>The null value.</para>
        /// </param>
        public static _JsErrorCode JsGetNullValue(out global::System.IntPtr nullValue)
        {
            global::System.IntPtr _nullValue;
            var __arg0 = &_nullValue;
            var __ret = __Internal.JsGetNullValue_0(__arg0);
            nullValue = _nullValue;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the value of true in the current script context.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="trueValue">
        /// <para>The true value.</para>
        /// </param>
        public static _JsErrorCode JsGetTrueValue(out global::System.IntPtr trueValue)
        {
            global::System.IntPtr _trueValue;
            var __arg0 = &_trueValue;
            var __ret = __Internal.JsGetTrueValue_0(__arg0);
            trueValue = _trueValue;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the value of false in the current script context.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="falseValue">
        /// <para>The false value.</para>
        /// </param>
        public static _JsErrorCode JsGetFalseValue(out global::System.IntPtr falseValue)
        {
            global::System.IntPtr _falseValue;
            var __arg0 = &_falseValue;
            var __ret = __Internal.JsGetFalseValue_0(__arg0);
            falseValue = _falseValue;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a Boolean value from a bool value.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="value">
        /// <para>The value to be converted.</para>
        /// </param>
        /// <param name="booleanValue">
        /// <para>The converted value.</para>
        /// </param>
        public static _JsErrorCode JsBoolToBoolean(bool value, out global::System.IntPtr booleanValue)
        {
            global::System.IntPtr _booleanValue;
            var __arg1 = &_booleanValue;
            var __ret = __Internal.JsBoolToBoolean_0(value, __arg1);
            booleanValue = _booleanValue;
            return __ret;
        }

        /// <summary>
        /// <para>Retrieves the bool value of a Boolean value.</para>
        /// </summary>
        /// <param name="value">
        /// <para>The value to be converted.</para>
        /// </param>
        /// <param name="boolValue">
        /// <para>The converted value.</para>
        /// </param>
        public static _JsErrorCode JsBooleanToBool(global::System.IntPtr value, out bool boolValue)
        {
            fixed (bool* __refParamPtr1 = &boolValue)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.JsBooleanToBool_0(value, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Converts the value to Boolean using standard JavaScript semantics.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="value">
        /// <para>The value to be converted.</para>
        /// </param>
        /// <param name="booleanValue">
        /// <para>The converted value.</para>
        /// </param>
        public static _JsErrorCode JsConvertValueToBoolean(global::System.IntPtr value, out global::System.IntPtr booleanValue)
        {
            global::System.IntPtr _booleanValue;
            var __arg1 = &_booleanValue;
            var __ret = __Internal.JsConvertValueToBoolean_0(value, __arg1);
            booleanValue = _booleanValue;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the JavaScript type of a JsValueRef.</para>
        /// </summary>
        /// <param name="value">
        /// <para>The value whose type is to be returned.</para>
        /// </param>
        /// <param name="type">
        /// <para>The type of the value.</para>
        /// </param>
        public static _JsErrorCode JsGetValueType(global::System.IntPtr value, out _JsValueType type)
        {
            _JsValueType _type;
            var __arg1 = &_type;
            var __ret = __Internal.JsGetValueType_0(value, __arg1);
            type = _type;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a number value from a double value.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="doubleValue">
        /// <para>The double to convert to a number value.</para>
        /// </param>
        /// <param name="value">
        /// <para>The new number value.</para>
        /// </param>
        public static _JsErrorCode JsDoubleToNumber(double doubleValue, out global::System.IntPtr value)
        {
            global::System.IntPtr _value;
            var __arg1 = &_value;
            var __ret = __Internal.JsDoubleToNumber_0(doubleValue, __arg1);
            value = _value;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a number value from an int value.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="intValue">
        /// <para>The int to convert to a number value.</para>
        /// </param>
        /// <param name="value">
        /// <para>The new number value.</para>
        /// </param>
        public static _JsErrorCode JsIntToNumber(int intValue, out global::System.IntPtr value)
        {
            global::System.IntPtr _value;
            var __arg1 = &_value;
            var __ret = __Internal.JsIntToNumber_0(intValue, __arg1);
            value = _value;
            return __ret;
        }

        /// <summary>
        /// <para>Retrieves the double value of a number value.</para>
        /// </summary>
        /// <remarks>
        /// <para>This function retrieves the value of a number value. It will fail with</para>
        /// <para>JsErrorInvalidArgument if the type of the value is not number.</para>
        /// </remarks>
        /// <param name="value">
        /// <para>The number value to convert to a double value.</para>
        /// </param>
        /// <param name="doubleValue">
        /// <para>The double value.</para>
        /// </param>
        public static _JsErrorCode JsNumberToDouble(global::System.IntPtr value, out double doubleValue)
        {
            fixed (double* __refParamPtr1 = &doubleValue)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.JsNumberToDouble_0(value, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Retrieves the int value of a number value.</para>
        /// </summary>
        /// <remarks>
        /// <para>This function retrieves the value of a number value and converts to an int value.</para>
        /// <para>It will fail with JsErrorInvalidArgument if the type of the value is not number.</para>
        /// </remarks>
        /// <param name="value">
        /// <para>The number value to convert to an int value.</para>
        /// </param>
        /// <param name="intValue">
        /// <para>The int value.</para>
        /// </param>
        public static _JsErrorCode JsNumberToInt(global::System.IntPtr value, out int intValue)
        {
            fixed (int* __refParamPtr1 = &intValue)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.JsNumberToInt_0(value, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Converts the value to number using standard JavaScript semantics.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="value">
        /// <para>The value to be converted.</para>
        /// </param>
        /// <param name="numberValue">
        /// <para>The converted value.</para>
        /// </param>
        public static _JsErrorCode JsConvertValueToNumber(global::System.IntPtr value, out global::System.IntPtr numberValue)
        {
            global::System.IntPtr _numberValue;
            var __arg1 = &_numberValue;
            var __ret = __Internal.JsConvertValueToNumber_0(value, __arg1);
            numberValue = _numberValue;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the length of a string value.</para>
        /// </summary>
        /// <param name="stringValue">
        /// <para>The string value to get the length of.</para>
        /// </param>
        /// <param name="length">
        /// <para>The length of the string.</para>
        /// </param>
        public static _JsErrorCode JsGetStringLength(global::System.IntPtr stringValue, out int length)
        {
            fixed (int* __refParamPtr1 = &length)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.JsGetStringLength_0(stringValue, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Converts the value to string using standard JavaScript semantics.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="value">
        /// <para>The value to be converted.</para>
        /// </param>
        /// <param name="stringValue">
        /// <para>The converted value.</para>
        /// </param>
        public static _JsErrorCode JsConvertValueToString(global::System.IntPtr value, out global::System.IntPtr stringValue)
        {
            global::System.IntPtr _stringValue;
            var __arg1 = &_stringValue;
            var __ret = __Internal.JsConvertValueToString_0(value, __arg1);
            stringValue = _stringValue;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the global object in the current script context.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="globalObject">
        /// <para>The global object.</para>
        /// </param>
        public static _JsErrorCode JsGetGlobalObject(out global::System.IntPtr globalObject)
        {
            global::System.IntPtr _globalObject;
            var __arg0 = &_globalObject;
            var __ret = __Internal.JsGetGlobalObject_0(__arg0);
            globalObject = _globalObject;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a new object.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The new object.</para>
        /// </param>
        public static _JsErrorCode JsCreateObject(out global::System.IntPtr targetObject)
        {
            global::System.IntPtr _targetObject;
            var __arg0 = &_targetObject;
            var __ret = __Internal.JsCreateObject_0(__arg0);
            targetObject = _targetObject;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a new object that stores some external data.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="data">
        /// <para>External data that the object will represent. May be null.</para>
        /// </param>
        /// <param name="finalizeCallback">
        /// <para>A callback for when the object is finalized. May be null.</para>
        /// </param>
        /// <param name="object">
        /// <para>The new object.</para>
        /// </param>
        public static _JsErrorCode JsCreateExternalObject(global::System.IntPtr data, JsFinalizeCallback finalizeCallback, out global::System.IntPtr targetObject)
        {
            var __arg1 = finalizeCallback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(finalizeCallback);
            global::System.IntPtr _targetObject;
            var __arg2 = &_targetObject;
            var __ret = __Internal.JsCreateExternalObject_0(data, __arg1, __arg2);
            targetObject = _targetObject;
            return __ret;
        }

        /// <summary>
        /// <para>Converts the value to object using standard JavaScript semantics.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="value">
        /// <para>The value to be converted.</para>
        /// </param>
        /// <param name="object">
        /// <para>The converted value.</para>
        /// </param>
        public static _JsErrorCode JsConvertValueToObject(global::System.IntPtr value, out global::System.IntPtr targetObject)
        {
            global::System.IntPtr _targetObject;
            var __arg1 = &_targetObject;
            var __ret = __Internal.JsConvertValueToObject_0(value, __arg1);
            targetObject = _targetObject;
            return __ret;
        }

        /// <summary>
        /// <para>Returns the prototype of an object.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object whose prototype is to be returned.</para>
        /// </param>
        /// <param name="prototypeObject">
        /// <para>The object's prototype.</para>
        /// </param>
        public static _JsErrorCode JsGetPrototype(global::System.IntPtr targetObject, out global::System.IntPtr prototypeObject)
        {
            global::System.IntPtr _prototypeObject;
            var __arg1 = &_prototypeObject;
            var __ret = __Internal.JsGetPrototype_0(targetObject, __arg1);
            prototypeObject = _prototypeObject;
            return __ret;
        }

        /// <summary>
        /// <para>Sets the prototype of an object.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object whose prototype is to be changed.</para>
        /// </param>
        /// <param name="prototypeObject">
        /// <para>The object's new prototype.</para>
        /// </param>
        public static _JsErrorCode JsSetPrototype(global::System.IntPtr targetObject, global::System.IntPtr prototypeObject)
        {
            var __ret = __Internal.JsSetPrototype_0(targetObject, prototypeObject);
            return __ret;
        }

        /// <summary>
        /// <para>Performs JavaScript &quot;instanceof&quot; operator test.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object to test.</para>
        /// </param>
        /// <param name="constructor">
        /// <para>The constructor function to test against.</para>
        /// </param>
        /// <param name="result">
        /// <para>Whether &quot;object instanceof constructor&quot; is true.</para>
        /// </param>
        public static _JsErrorCode JsInstanceOf(global::System.IntPtr targetObject, global::System.IntPtr constructor, out bool result)
        {
            fixed (bool* __refParamPtr2 = &result)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.JsInstanceOf_0(targetObject, constructor, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns a value that indicates whether an object is extensible or not.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object to test.</para>
        /// </param>
        /// <param name="value">
        /// <para>Whether the object is extensible or not.</para>
        /// </param>
        public static _JsErrorCode JsGetExtensionAllowed(global::System.IntPtr targetObject, out bool value)
        {
            fixed (bool* __refParamPtr1 = &value)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.JsGetExtensionAllowed_0(targetObject, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Makes an object non-extensible.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object to make non-extensible.</para>
        /// </param>
        public static _JsErrorCode JsPreventExtension(global::System.IntPtr targetObject)
        {
            var __ret = __Internal.JsPreventExtension_0(targetObject);
            return __ret;
        }

        /// <summary>
        /// <para>Gets an object's property.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object that contains the property.</para>
        /// </param>
        /// <param name="propertyId">
        /// <para>The ID of the property.</para>
        /// </param>
        /// <param name="value">
        /// <para>The value of the property.</para>
        /// </param>
        public static _JsErrorCode JsGetProperty(global::System.IntPtr targetObject, global::System.IntPtr propertyId, out global::System.IntPtr value)
        {
            global::System.IntPtr _value;
            var __arg2 = &_value;
            var __ret = __Internal.JsGetProperty_0(targetObject, propertyId, __arg2);
            value = _value;
            return __ret;
        }

        /// <summary>
        /// <para>Gets a property descriptor for an object's own property.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object that has the property.</para>
        /// </param>
        /// <param name="propertyId">
        /// <para>The ID of the property.</para>
        /// </param>
        /// <param name="propertyDescriptor">
        /// <para>The property descriptor.</para>
        /// </param>
        public static _JsErrorCode JsGetOwnPropertyDescriptor(global::System.IntPtr targetObject, global::System.IntPtr propertyId, out global::System.IntPtr propertyDescriptor)
        {
            global::System.IntPtr _propertyDescriptor;
            var __arg2 = &_propertyDescriptor;
            var __ret = __Internal.JsGetOwnPropertyDescriptor_0(targetObject, propertyId, __arg2);
            propertyDescriptor = _propertyDescriptor;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the list of all properties on the object.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object from which to get the property names.</para>
        /// </param>
        /// <param name="propertyNames">
        /// <para>An array of property names.</para>
        /// </param>
        public static _JsErrorCode JsGetOwnPropertyNames(global::System.IntPtr targetObject, out global::System.IntPtr propertyNames)
        {
            global::System.IntPtr _propertyNames;
            var __arg1 = &_propertyNames;
            var __ret = __Internal.JsGetOwnPropertyNames_0(targetObject, __arg1);
            propertyNames = _propertyNames;
            return __ret;
        }

        /// <summary>
        /// <para>Puts an object's property.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object that contains the property.</para>
        /// </param>
        /// <param name="propertyId">
        /// <para>The ID of the property.</para>
        /// </param>
        /// <param name="value">
        /// <para>The new value of the property.</para>
        /// </param>
        /// <param name="useStrictRules">
        /// <para>The property set should follow strict mode rules.</para>
        /// </param>
        public static _JsErrorCode JsSetProperty(global::System.IntPtr targetObject, global::System.IntPtr propertyId, global::System.IntPtr value, bool useStrictRules)
        {
            var __ret = __Internal.JsSetProperty_0(targetObject, propertyId, value, useStrictRules);
            return __ret;
        }

        /// <summary>
        /// <para>Determines whether an object has a property.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object that may contain the property.</para>
        /// </param>
        /// <param name="propertyId">
        /// <para>The ID of the property.</para>
        /// </param>
        /// <param name="hasProperty">
        /// <para>Whether the object (or a prototype) has the property.</para>
        /// </param>
        public static _JsErrorCode JsHasProperty(global::System.IntPtr targetObject, global::System.IntPtr propertyId, out bool hasProperty)
        {
            fixed (bool* __refParamPtr2 = &hasProperty)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.JsHasProperty_0(targetObject, propertyId, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Deletes an object's property.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object that contains the property.</para>
        /// </param>
        /// <param name="propertyId">
        /// <para>The ID of the property.</para>
        /// </param>
        /// <param name="useStrictRules">
        /// <para>The property set should follow strict mode rules.</para>
        /// </param>
        /// <param name="result">
        /// <para>Whether the property was deleted.</para>
        /// </param>
        public static _JsErrorCode JsDeleteProperty(global::System.IntPtr targetObject, global::System.IntPtr propertyId, bool useStrictRules, out global::System.IntPtr result)
        {
            global::System.IntPtr _result;
            var __arg3 = &_result;
            var __ret = __Internal.JsDeleteProperty_0(targetObject, propertyId, useStrictRules, __arg3);
            result = _result;
            return __ret;
        }

        /// <summary>
        /// <para>Defines a new object's own property from a property descriptor.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object that has the property.</para>
        /// </param>
        /// <param name="propertyId">
        /// <para>The ID of the property.</para>
        /// </param>
        /// <param name="propertyDescriptor">
        /// <para>The property descriptor.</para>
        /// </param>
        /// <param name="result">
        /// <para>Whether the property was defined.</para>
        /// </param>
        public static _JsErrorCode JsDefineProperty(global::System.IntPtr targetObject, global::System.IntPtr propertyId, global::System.IntPtr propertyDescriptor, out bool result)
        {
            fixed (bool* __refParamPtr3 = &result)
            {
                var __arg3 = __refParamPtr3;
                var __ret = __Internal.JsDefineProperty_0(targetObject, propertyId, propertyDescriptor, __arg3);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Tests whether an object has a value at the specified index.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object to operate on.</para>
        /// </param>
        /// <param name="index">
        /// <para>The index to test.</para>
        /// </param>
        /// <param name="result">
        /// <para>Whether the object has a value at the specified index.</para>
        /// </param>
        public static _JsErrorCode JsHasIndexedProperty(global::System.IntPtr targetObject, global::System.IntPtr index, out bool result)
        {
            fixed (bool* __refParamPtr2 = &result)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.JsHasIndexedProperty_0(targetObject, index, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Retrieve the value at the specified index of an object.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object to operate on.</para>
        /// </param>
        /// <param name="index">
        /// <para>The index to retrieve.</para>
        /// </param>
        /// <param name="result">
        /// <para>The retrieved value.</para>
        /// </param>
        public static _JsErrorCode JsGetIndexedProperty(global::System.IntPtr targetObject, global::System.IntPtr index, out global::System.IntPtr result)
        {
            global::System.IntPtr _result;
            var __arg2 = &_result;
            var __ret = __Internal.JsGetIndexedProperty_0(targetObject, index, __arg2);
            result = _result;
            return __ret;
        }

        /// <summary>
        /// <para>Set the value at the specified index of an object.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object to operate on.</para>
        /// </param>
        /// <param name="index">
        /// <para>The index to set.</para>
        /// </param>
        /// <param name="value">
        /// <para>The value to set.</para>
        /// </param>
        public static _JsErrorCode JsSetIndexedProperty(global::System.IntPtr targetObject, global::System.IntPtr index, global::System.IntPtr value)
        {
            var __ret = __Internal.JsSetIndexedProperty_0(targetObject, index, value);
            return __ret;
        }

        /// <summary>
        /// <para>Delete the value at the specified index of an object.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object to operate on.</para>
        /// </param>
        /// <param name="index">
        /// <para>The index to delete.</para>
        /// </param>
        public static _JsErrorCode JsDeleteIndexedProperty(global::System.IntPtr targetObject, global::System.IntPtr index)
        {
            var __ret = __Internal.JsDeleteIndexedProperty_0(targetObject, index);
            return __ret;
        }

        /// <summary>
        /// <para>Determines whether an object has its indexed properties in external data.</para>
        /// </summary>
        /// <param name="object">
        /// <para>The object.</para>
        /// </param>
        /// <param name="value">
        /// <para>Whether the object has its indexed properties in external data.</para>
        /// </param>
        public static _JsErrorCode JsHasIndexedPropertiesExternalData(global::System.IntPtr targetObject, out bool value)
        {
            fixed (bool* __refParamPtr1 = &value)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.JsHasIndexedPropertiesExternalData_0(targetObject, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Retrieves an object's indexed properties external data information.</para>
        /// </summary>
        /// <param name="object">
        /// <para>The object.</para>
        /// </param>
        /// <param name="data">
        /// <para>The external data back store for the object's indexed properties.</para>
        /// </param>
        /// <param name="arrayType">
        /// <para>The array element type in external data.</para>
        /// </param>
        /// <param name="elementLength">
        /// <para>The number of array elements in external data.</para>
        /// </param>
        public static _JsErrorCode JsGetIndexedPropertiesExternalData(global::System.IntPtr targetObject, out global::System.IntPtr data, out _JsTypedArrayType arrayType, out uint elementLength)
        {
            global::System.IntPtr _data;
            var __arg1 = &_data;
            _JsTypedArrayType _arrayType;
            var __arg2 = &_arrayType;
            fixed (uint* __refParamPtr3 = &elementLength)
            {
                var __arg3 = __refParamPtr3;
                var __ret = __Internal.JsGetIndexedPropertiesExternalData_0(targetObject, __arg1, __arg2, __arg3);
                data = _data;
                arrayType = _arrayType;
                return __ret;
            }
        }

        /// <summary>
        /// <para>Sets an object's indexed properties to external data. The external data will be used as back     store for the object's indexed properties and accessed like a typed array.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object">
        /// <para>The object to operate on.</para>
        /// </param>
        /// <param name="data">
        /// <para>The external data to be used as back store for the object's indexed properties.</para>
        /// </param>
        /// <param name="arrayType">
        /// <para>The array element type in external data.</para>
        /// </param>
        /// <param name="elementLength">
        /// <para>The number of array elements in external data.</para>
        /// </param>
        public static _JsErrorCode JsSetIndexedPropertiesToExternalData(global::System.IntPtr targetObject, global::System.IntPtr data, _JsTypedArrayType arrayType, uint elementLength)
        {
            var __ret = __Internal.JsSetIndexedPropertiesToExternalData_0(targetObject, data, arrayType, elementLength);
            return __ret;
        }

        /// <summary>
        /// <para>Compare two JavaScript values for equality.</para>
        /// </summary>
        /// <remarks>
        /// <para>This function is equivalent to the == operator in Javascript.</para>
        /// <para></para>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object1">
        /// <para>The first object to compare.</para>
        /// </param>
        /// <param name="object2">
        /// <para>The second object to compare.</para>
        /// </param>
        /// <param name="result">
        /// <para>Whether the values are equal.</para>
        /// </param>
        public static _JsErrorCode JsEquals(global::System.IntPtr object1, global::System.IntPtr object2, out bool result)
        {
            fixed (bool* __refParamPtr2 = &result)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.JsEquals_0(object1, object2, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Compare two JavaScript values for strict equality.</para>
        /// </summary>
        /// <remarks>
        /// <para>This function is equivalent to the === operator in Javascript.</para>
        /// <para></para>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="object1">
        /// <para>The first object to compare.</para>
        /// </param>
        /// <param name="object2">
        /// <para>The second object to compare.</para>
        /// </param>
        /// <param name="result">
        /// <para>Whether the values are strictly equal.</para>
        /// </param>
        public static _JsErrorCode JsStrictEquals(global::System.IntPtr object1, global::System.IntPtr object2, out bool result)
        {
            fixed (bool* __refParamPtr2 = &result)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.JsStrictEquals_0(object1, object2, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Determines whether an object is an external object.</para>
        /// </summary>
        /// <param name="object">
        /// <para>The object.</para>
        /// </param>
        /// <param name="value">
        /// <para>Whether the object is an external object.</para>
        /// </param>
        public static _JsErrorCode JsHasExternalData(global::System.IntPtr targetObject, out bool value)
        {
            fixed (bool* __refParamPtr1 = &value)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.JsHasExternalData_0(targetObject, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Retrieves the data from an external object.</para>
        /// </summary>
        /// <param name="object">
        /// <para>The external object.</para>
        /// </param>
        /// <param name="externalData">
        /// <para>The external data stored in the object. Can be null if no external data is stored in the object.</para>
        /// </param>
        public static _JsErrorCode JsGetExternalData(global::System.IntPtr targetObject, out global::System.IntPtr externalData)
        {
            global::System.IntPtr _externalData;
            var __arg1 = &_externalData;
            var __ret = __Internal.JsGetExternalData_0(targetObject, __arg1);
            externalData = _externalData;
            return __ret;
        }

        /// <summary>
        /// <para>Sets the external data on an external object.</para>
        /// </summary>
        /// <param name="object">
        /// <para>The external object.</para>
        /// </param>
        /// <param name="externalData">
        /// <para>The external data to be stored in the object. Can be null if no external data is to be stored in the object.</para>
        /// </param>
        public static _JsErrorCode JsSetExternalData(global::System.IntPtr targetObject, global::System.IntPtr externalData)
        {
            var __ret = __Internal.JsSetExternalData_0(targetObject, externalData);
            return __ret;
        }

        /// <summary>
        /// <para>Creates a Javascript array object.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="length">
        /// <para>The initial length of the array.</para>
        /// </param>
        /// <param name="result">
        /// <para>The new array object.</para>
        /// </param>
        public static _JsErrorCode JsCreateArray(uint length, out global::System.IntPtr result)
        {
            global::System.IntPtr _result;
            var __arg1 = &_result;
            var __ret = __Internal.JsCreateArray_0(length, __arg1);
            result = _result;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a Javascript ArrayBuffer object.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="byteLength">
        /// <para>The number of bytes in the ArrayBuffer.</para>
        /// </param>
        /// <param name="result">
        /// <para>The new ArrayBuffer object.</para>
        /// </param>
        public static _JsErrorCode JsCreateArrayBuffer(uint byteLength, out global::System.IntPtr result)
        {
            global::System.IntPtr _result;
            var __arg1 = &_result;
            var __ret = __Internal.JsCreateArrayBuffer_0(byteLength, __arg1);
            result = _result;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a Javascript ArrayBuffer object to access external memory.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="data">
        /// <para>A pointer to the external memory.</para>
        /// </param>
        /// <param name="byteLength">
        /// <para>The number of bytes in the external memory.</para>
        /// </param>
        /// <param name="finalizeCallback">
        /// <para>A callback for when the object is finalized. May be null.</para>
        /// </param>
        /// <param name="callbackState">
        /// <para>User provided state that will be passed back to finalizeCallback.</para>
        /// </param>
        /// <param name="result">
        /// <para>The new ArrayBuffer object.</para>
        /// </param>
        public static _JsErrorCode JsCreateExternalArrayBuffer(global::System.IntPtr data, uint byteLength, JsFinalizeCallback finalizeCallback, global::System.IntPtr callbackState, out global::System.IntPtr result)
        {
            var __arg2 = finalizeCallback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(finalizeCallback);
            global::System.IntPtr _result;
            var __arg4 = &_result;
            var __ret = __Internal.JsCreateExternalArrayBuffer_0(data, byteLength, __arg2, callbackState, __arg4);
            result = _result;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a Javascript typed array object.</para>
        /// </summary>
        /// <remarks>
        /// <para>The baseArray can be an ArrayBuffer, another typed array, or a JavaScript</para>
        /// <para>Array. The returned typed array will use the baseArray if it is an ArrayBuffer, or</para>
        /// <para>otherwise create and use a copy of the underlying source array.</para>
        /// <para></para>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="arrayType">
        /// <para>The type of the array to create.</para>
        /// </param>
        /// <param name="baseArray">
        /// <para>The base array of the new array. Use JS_INVALID_REFERENCE if no base array.</para>
        /// </param>
        /// <param name="byteOffset">
        /// <para>The offset in bytes from the start of baseArray (ArrayBuffer) for result typed array to reference. Only applicable when baseArray is an ArrayBuffer object. Must be 0 otherwise.</para>
        /// </param>
        /// <param name="elementLength">
        /// <para>The number of elements in the array. Only applicable when creating a new typed array without baseArray (baseArray is JS_INVALID_REFERENCE) or when baseArray is an ArrayBuffer object. Must be 0 otherwise.</para>
        /// </param>
        /// <param name="result">
        /// <para>The new typed array object.</para>
        /// </param>
        public static _JsErrorCode JsCreateTypedArray(_JsTypedArrayType arrayType, global::System.IntPtr baseArray, uint byteOffset, uint elementLength, out global::System.IntPtr result)
        {
            global::System.IntPtr _result;
            var __arg4 = &_result;
            var __ret = __Internal.JsCreateTypedArray_0(arrayType, baseArray, byteOffset, elementLength, __arg4);
            result = _result;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a Javascript DataView object.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="arrayBuffer">
        /// <para>An existing ArrayBuffer object to use as the storage for the result DataView object.</para>
        /// </param>
        /// <param name="byteOffset">
        /// <para>The offset in bytes from the start of arrayBuffer for result DataView to reference.</para>
        /// </param>
        /// <param name="byteLength">
        /// <para>The number of bytes in the ArrayBuffer for result DataView to reference.</para>
        /// </param>
        /// <param name="result">
        /// <para>The new DataView object.</para>
        /// </param>
        public static _JsErrorCode JsCreateDataView(global::System.IntPtr arrayBuffer, uint byteOffset, uint byteLength, out global::System.IntPtr result)
        {
            global::System.IntPtr _result;
            var __arg3 = &_result;
            var __ret = __Internal.JsCreateDataView_0(arrayBuffer, byteOffset, byteLength, __arg3);
            result = _result;
            return __ret;
        }

        /// <summary>
        /// <para>Obtains frequently used properties of a typed array.</para>
        /// </summary>
        /// <param name="typedArray">
        /// <para>The typed array instance.</para>
        /// </param>
        /// <param name="arrayType">
        /// <para>The type of the array.</para>
        /// </param>
        /// <param name="arrayBuffer">
        /// <para>The ArrayBuffer backstore of the array.</para>
        /// </param>
        /// <param name="byteOffset">
        /// <para>The offset in bytes from the start of arrayBuffer referenced by the array.</para>
        /// </param>
        /// <param name="byteLength">
        /// <para>The number of bytes in the array.</para>
        /// </param>
        public static _JsErrorCode JsGetTypedArrayInfo(global::System.IntPtr typedArray, out _JsTypedArrayType arrayType, out global::System.IntPtr arrayBuffer, out uint byteOffset, out uint byteLength)
        {
            _JsTypedArrayType _arrayType;
            var __arg1 = &_arrayType;
            global::System.IntPtr _arrayBuffer;
            var __arg2 = &_arrayBuffer;
            fixed (uint* __refParamPtr3 = &byteOffset)
            {
                var __arg3 = __refParamPtr3;
                fixed (uint* __refParamPtr4 = &byteLength)
                {
                    var __arg4 = __refParamPtr4;
                    var __ret = __Internal.JsGetTypedArrayInfo_0(typedArray, __arg1, __arg2, __arg3, __arg4);
                    arrayType = _arrayType;
                    arrayBuffer = _arrayBuffer;
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Obtains the underlying memory storage used by an ArrayBuffer.</para>
        /// </summary>
        /// <param name="arrayBuffer">
        /// <para>The ArrayBuffer instance.</para>
        /// </param>
        /// <param name="buffer">
        /// <para>The ArrayBuffer's buffer. The lifetime of the buffer returned is the same as the lifetime of the the ArrayBuffer. The buffer pointer does not count as a reference to the ArrayBuffer for the purpose of garbage collection.</para>
        /// </param>
        /// <param name="bufferLength">
        /// <para>The number of bytes in the buffer.</para>
        /// </param>
        public static _JsErrorCode JsGetArrayBufferStorage(global::System.IntPtr arrayBuffer, out global::System.IntPtr buffer, out uint bufferLength)
        {
            global::System.IntPtr _buffer;
            var __arg1 = &_buffer;
            fixed (uint* __refParamPtr2 = &bufferLength)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.JsGetArrayBufferStorage_0(arrayBuffer, __arg1, __arg2);
                buffer = _buffer;
                return __ret;
            }
        }

        /// <summary>
        /// <para>Obtains the underlying memory storage used by a typed array.</para>
        /// </summary>
        /// <param name="typedArray">
        /// <para>The typed array instance.</para>
        /// </param>
        /// <param name="buffer">
        /// <para>The array's buffer. The lifetime of the buffer returned is the same as the lifetime of the the array. The buffer pointer does not count as a reference to the array for the purpose of garbage collection.</para>
        /// </param>
        /// <param name="bufferLength">
        /// <para>The number of bytes in the buffer.</para>
        /// </param>
        /// <param name="arrayType">
        /// <para>The type of the array.</para>
        /// </param>
        /// <param name="elementSize">
        /// <para>The size of an element of the array.</para>
        /// </param>
        public static _JsErrorCode JsGetTypedArrayStorage(global::System.IntPtr typedArray, out global::System.IntPtr buffer, out uint bufferLength, out _JsTypedArrayType arrayType, out int elementSize)
        {
            global::System.IntPtr _buffer;
            var __arg1 = &_buffer;
            fixed (uint* __refParamPtr2 = &bufferLength)
            {
                var __arg2 = __refParamPtr2;
                _JsTypedArrayType _arrayType;
                var __arg3 = &_arrayType;
                fixed (int* __refParamPtr4 = &elementSize)
                {
                    var __arg4 = __refParamPtr4;
                    var __ret = __Internal.JsGetTypedArrayStorage_0(typedArray, __arg1, __arg2, __arg3, __arg4);
                    buffer = _buffer;
                    arrayType = _arrayType;
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>Obtains the underlying memory storage used by a DataView.</para>
        /// </summary>
        /// <param name="dataView">
        /// <para>The DataView instance.</para>
        /// </param>
        /// <param name="buffer">
        /// <para>The DataView's buffer. The lifetime of the buffer returned is the same as the lifetime of the the DataView. The buffer pointer does not count as a reference to the DataView for the purpose of garbage collection.</para>
        /// </param>
        /// <param name="bufferLength">
        /// <para>The number of bytes in the buffer.</para>
        /// </param>
        public static _JsErrorCode JsGetDataViewStorage(global::System.IntPtr dataView, out global::System.IntPtr buffer, out uint bufferLength)
        {
            global::System.IntPtr _buffer;
            var __arg1 = &_buffer;
            fixed (uint* __refParamPtr2 = &bufferLength)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.JsGetDataViewStorage_0(dataView, __arg1, __arg2);
                buffer = _buffer;
                return __ret;
            }
        }

        /// <summary>
        /// <para>Invokes a function.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires thisArg as first argument of arguments.</para>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="function">
        /// <para>The function to invoke.</para>
        /// </param>
        /// <param name="arguments">
        /// <para>The arguments to the call.</para>
        /// </param>
        /// <param name="argumentCount">
        /// <para>The number of arguments being passed in to the function.</para>
        /// </param>
        /// <param name="result">
        /// <para>The value returned from the function invocation, if any.</para>
        /// </param>
        public static _JsErrorCode JsCallFunction(global::System.IntPtr function, global::System.IntPtr arguments, ushort argumentCount, out global::System.IntPtr result)
        {
            global::System.IntPtr _result;
            var __arg3 = &_result;
            var __ret = __Internal.JsCallFunction_0(function, arguments, argumentCount, __arg3);
            result = _result;
            return __ret;
        }

        /// <summary>
        /// <para>Invokes a function as a constructor.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="function">
        /// <para>The function to invoke as a constructor.</para>
        /// </param>
        /// <param name="arguments">
        /// <para>The arguments to the call.</para>
        /// </param>
        /// <param name="argumentCount">
        /// <para>The number of arguments being passed in to the function.</para>
        /// </param>
        /// <param name="result">
        /// <para>The value returned from the function invocation.</para>
        /// </param>
        public static _JsErrorCode JsConstructObject(global::System.IntPtr function, global::System.IntPtr arguments, ushort argumentCount, out global::System.IntPtr result)
        {
            global::System.IntPtr _result;
            var __arg3 = &_result;
            var __ret = __Internal.JsConstructObject_0(function, arguments, argumentCount, __arg3);
            result = _result;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a new JavaScript function.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="nativeFunction">
        /// <para>The method to call when the function is invoked.</para>
        /// </param>
        /// <param name="callbackState">
        /// <para>User provided state that will be passed back to the callback.</para>
        /// </param>
        /// <param name="function">
        /// <para>The new function object.</para>
        /// </param>
        public static _JsErrorCode JsCreateFunction(JsNativeFunction nativeFunction, global::System.IntPtr callbackState, out global::System.IntPtr function)
        {
            var __arg0 = nativeFunction == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(nativeFunction);
            global::System.IntPtr _function;
            var __arg2 = &_function;
            var __ret = __Internal.JsCreateFunction_0(__arg0, callbackState, __arg2);
            function = _function;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a new JavaScript function with name.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="name">
        /// <para>The name of this function that will be used for diagnostics and stringification purposes.</para>
        /// </param>
        /// <param name="nativeFunction">
        /// <para>The method to call when the function is invoked.</para>
        /// </param>
        /// <param name="callbackState">
        /// <para>User provided state that will be passed back to the callback.</para>
        /// </param>
        /// <param name="function">
        /// <para>The new function object.</para>
        /// </param>
        public static _JsErrorCode JsCreateNamedFunction(global::System.IntPtr name, JsNativeFunction nativeFunction, global::System.IntPtr callbackState, out global::System.IntPtr function)
        {
            var __arg1 = nativeFunction == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(nativeFunction);
            global::System.IntPtr _function;
            var __arg3 = &_function;
            var __ret = __Internal.JsCreateNamedFunction_0(name, __arg1, callbackState, __arg3);
            function = _function;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a new JavaScript error object</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="message">
        /// <para>Message for the error object.</para>
        /// </param>
        /// <param name="error">
        /// <para>The new error object.</para>
        /// </param>
        public static _JsErrorCode JsCreateError(global::System.IntPtr message, out global::System.IntPtr error)
        {
            global::System.IntPtr _error;
            var __arg1 = &_error;
            var __ret = __Internal.JsCreateError_0(message, __arg1);
            error = _error;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a new JavaScript RangeError error object</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="message">
        /// <para>Message for the error object.</para>
        /// </param>
        /// <param name="error">
        /// <para>The new error object.</para>
        /// </param>
        public static _JsErrorCode JsCreateRangeError(global::System.IntPtr message, out global::System.IntPtr error)
        {
            global::System.IntPtr _error;
            var __arg1 = &_error;
            var __ret = __Internal.JsCreateRangeError_0(message, __arg1);
            error = _error;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a new JavaScript ReferenceError error object</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="message">
        /// <para>Message for the error object.</para>
        /// </param>
        /// <param name="error">
        /// <para>The new error object.</para>
        /// </param>
        public static _JsErrorCode JsCreateReferenceError(global::System.IntPtr message, out global::System.IntPtr error)
        {
            global::System.IntPtr _error;
            var __arg1 = &_error;
            var __ret = __Internal.JsCreateReferenceError_0(message, __arg1);
            error = _error;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a new JavaScript SyntaxError error object</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="message">
        /// <para>Message for the error object.</para>
        /// </param>
        /// <param name="error">
        /// <para>The new error object.</para>
        /// </param>
        public static _JsErrorCode JsCreateSyntaxError(global::System.IntPtr message, out global::System.IntPtr error)
        {
            global::System.IntPtr _error;
            var __arg1 = &_error;
            var __ret = __Internal.JsCreateSyntaxError_0(message, __arg1);
            error = _error;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a new JavaScript TypeError error object</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="message">
        /// <para>Message for the error object.</para>
        /// </param>
        /// <param name="error">
        /// <para>The new error object.</para>
        /// </param>
        public static _JsErrorCode JsCreateTypeError(global::System.IntPtr message, out global::System.IntPtr error)
        {
            global::System.IntPtr _error;
            var __arg1 = &_error;
            var __ret = __Internal.JsCreateTypeError_0(message, __arg1);
            error = _error;
            return __ret;
        }

        /// <summary>
        /// <para>Creates a new JavaScript URIError error object</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="message">
        /// <para>Message for the error object.</para>
        /// </param>
        /// <param name="error">
        /// <para>The new error object.</para>
        /// </param>
        public static _JsErrorCode JsCreateURIError(global::System.IntPtr message, out global::System.IntPtr error)
        {
            global::System.IntPtr _error;
            var __arg1 = &_error;
            var __ret = __Internal.JsCreateURIError_0(message, __arg1);
            error = _error;
            return __ret;
        }

        /// <summary>
        /// <para>Determines whether the runtime of the current context is in an exception state.</para>
        /// </summary>
        /// <remarks>
        /// <para>If a call into the runtime results in an exception (either as the result of running a</para>
        /// <para>script or due to something like a conversion failure), the runtime is placed into an</para>
        /// <para>&quot;exception state.&quot; All calls into any context created by the runtime (except for the</para>
        /// <para>exception APIs) will fail with JsErrorInExceptionState until the exception is</para>
        /// <para>cleared.</para>
        /// <para></para>
        /// <para>If the runtime of the current context is in the exception state when a callback returns</para>
        /// <para>into the engine, the engine will automatically rethrow the exception.</para>
        /// <para></para>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="hasException">
        /// <para>Whether the runtime of the current context is in the exception state.</para>
        /// </param>
        public static _JsErrorCode JsHasException(out bool hasException)
        {
            fixed (bool* __refParamPtr0 = &hasException)
            {
                var __arg0 = __refParamPtr0;
                var __ret = __Internal.JsHasException_0(__arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Returns the exception that caused the runtime of the current context to be in the     exception state and resets the exception state for that runtime.</para>
        /// </summary>
        /// <remarks>
        /// <para>If the runtime of the current context is not in an exception state, this API will return</para>
        /// <para>JsErrorInvalidArgument. If the runtime is disabled, this will return an exception</para>
        /// <para>indicating that the script was terminated, but it will not clear the exception (the</para>
        /// <para>exception will be cleared if the runtime is re-enabled using</para>
        /// <para>JsEnableRuntimeExecution).</para>
        /// <para></para>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="exception">
        /// <para>The exception for the runtime of the current context.</para>
        /// </param>
        public static _JsErrorCode JsGetAndClearException(out global::System.IntPtr exception)
        {
            global::System.IntPtr _exception;
            var __arg0 = &_exception;
            var __ret = __Internal.JsGetAndClearException_0(__arg0);
            exception = _exception;
            return __ret;
        }

        /// <summary>
        /// <para>Sets the runtime of the current context to an exception state.</para>
        /// </summary>
        /// <remarks>
        /// <para>If the runtime of the current context is already in an exception state, this API will</para>
        /// <para>return JsErrorInExceptionState.</para>
        /// <para></para>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="exception">
        /// <para>The JavaScript exception to set for the runtime of the current context.</para>
        /// </param>
        public static _JsErrorCode JsSetException(global::System.IntPtr exception)
        {
            var __ret = __Internal.JsSetException_0(exception);
            return __ret;
        }

        /// <summary>
        /// <para>Suspends script execution and terminates any running scripts in a runtime.</para>
        /// </summary>
        /// <remarks>
        /// <para>Calls to a suspended runtime will fail until JsEnableRuntimeExecution is called.</para>
        /// <para></para>
        /// <para>This API does not have to be called on the thread the runtime is active on. Although the</para>
        /// <para>runtime will be set into a suspended state, an executing script may not be suspended</para>
        /// <para>immediately; a running script will be terminated with an uncatchable exception as soon as</para>
        /// <para>possible.</para>
        /// <para></para>
        /// <para>Suspending execution in a runtime that is already suspended is a no-op.</para>
        /// </remarks>
        /// <param name="runtime">
        /// <para>The runtime to be suspended.</para>
        /// </param>
        public static _JsErrorCode JsDisableRuntimeExecution(global::System.IntPtr runtime)
        {
            var __ret = __Internal.JsDisableRuntimeExecution_0(runtime);
            return __ret;
        }

        /// <summary>
        /// <para>Enables script execution in a runtime.</para>
        /// </summary>
        /// <remarks>
        /// <para>Enabling script execution in a runtime that already has script execution enabled is a</para>
        /// <para>no-op.</para>
        /// </remarks>
        /// <param name="runtime">
        /// <para>The runtime to be enabled.</para>
        /// </param>
        public static _JsErrorCode JsEnableRuntimeExecution(global::System.IntPtr runtime)
        {
            var __ret = __Internal.JsEnableRuntimeExecution_0(runtime);
            return __ret;
        }

        /// <summary>
        /// <para>Returns a value that indicates whether script execution is disabled in the runtime.</para>
        /// </summary>
        /// <param name="runtime">
        /// <para>Specifies the runtime to check if execution is disabled.</para>
        /// </param>
        /// <param name="isDisabled">
        /// <para>If execution is disabled, true, false otherwise.</para>
        /// </param>
        public static _JsErrorCode JsIsRuntimeExecutionDisabled(global::System.IntPtr runtime, out bool isDisabled)
        {
            fixed (bool* __refParamPtr1 = &isDisabled)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.JsIsRuntimeExecutionDisabled_0(runtime, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Sets a promise continuation callback function that is called by the context when a task     needs to be queued for future execution</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires an active script context.</para>
        /// </remarks>
        /// <param name="promiseContinuationCallback">
        /// <para>The callback function being set.</para>
        /// </param>
        /// <param name="callbackState">
        /// <para>User provided state that will be passed back to the callback.</para>
        /// </param>
        public static _JsErrorCode JsSetPromiseContinuationCallback(JsPromiseContinuationCallback promiseContinuationCallback, global::System.IntPtr callbackState)
        {
            var __arg0 = promiseContinuationCallback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(promiseContinuationCallback);
            var __ret = __Internal.JsSetPromiseContinuationCallback_0(__arg0, callbackState);
            return __ret;
        }

        /// <summary>
        /// <para>An invalid runtime handle.</para>
        /// </summary>
        public static global::System.IntPtr JS_INVALID_RUNTIME_HANDLE
        {
            get
            {
                var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("ChakraCore", "JS_INVALID_RUNTIME_HANDLE");
                return *__ptr;
            }
        }

        /// <summary>
        /// <para>An invalid reference.</para>
        /// </summary>
        public static global::System.IntPtr JS_INVALID_REFERENCE
        {
            get
            {
                var __ptr = (global::System.IntPtr*)CppSharp.SymbolResolver.ResolveSymbol("ChakraCore", "JS_INVALID_REFERENCE");
                return *__ptr;
            }
        }

        /// <summary>
        /// <para>An empty source context.</para>
        /// </summary>
        public static ulong JS_SOURCE_CONTEXT_NONE
        {
            get
            {
                var __ptr = (ulong*)CppSharp.SymbolResolver.ResolveSymbol("ChakraCore", "JS_SOURCE_CONTEXT_NONE");
                return *__ptr;
            }
        }
    }

    /// <summary>
    /// <para>Debug events reported from ChakraCore engine.</para>
    /// </summary>
    public enum _JsDiagDebugEvent
    {
        /// <summary>Indicates a new script being compiled, this includes script, eval, new function.</summary>
        JsDiagDebugEventSourceCompile = 0,
        /// <summary>Indicates compile error for a script.</summary>
        JsDiagDebugEventCompileError = 1,
        /// <summary>Indicates a break due to a breakpoint.</summary>
        JsDiagDebugEventBreakpoint = 2,
        /// <summary>Indicates a break after completion of step action.</summary>
        JsDiagDebugEventStepComplete = 3,
        /// <summary>Indicates a break due to debugger statement.</summary>
        JsDiagDebugEventDebuggerStatement = 4,
        /// <summary>Indicates a break due to async break.</summary>
        JsDiagDebugEventAsyncBreak = 5,
        /// <summary>Indicates a break due to a runtime script exception.</summary>
        JsDiagDebugEventRuntimeException = 6
    }

    /// <summary>
    /// <para>Break on Exception attributes.</para>
    /// </summary>
    public enum _JsDiagBreakOnExceptionAttributes
    {
        /// <summary>Don't break on any exception.</summary>
        JsDiagBreakOnExceptionAttributeNone = 0,
        /// <summary>Break on uncaught exception.</summary>
        JsDiagBreakOnExceptionAttributeUncaught = 1,
        /// <summary>Break on first chance exception.</summary>
        JsDiagBreakOnExceptionAttributeFirstChance = 2
    }

    /// <summary>
    /// <para>Stepping types.</para>
    /// </summary>
    public enum _JsDiagStepType
    {
        /// <summary>Perform a step operation to next statement.</summary>
        JsDiagStepTypeStepIn = 0,
        /// <summary>Perform a step out from the current function.</summary>
        JsDiagStepTypeStepOut = 1,
        /// <summary>Perform a single step over after a debug break if the next statement is a function call, else behaves as a stepin.</summary>
        JsDiagStepTypeStepOver = 2,
        /// <summary>Perform a single step back to the previous statement (only applicable in TTD mode).</summary>
        JsDiagStepTypeStepBack = 3,
        /// <summary>Perform a reverse continue operation (only applicable in TTD mode).</summary>
        JsDiagStepTypeStepReverseContinue = 4
    }

    /// <summary>
    /// <para>TimeTravel move options as bit flag enum.</para>
    /// </summary>
    [Flags]
    public enum _JsTTDMoveModes
    {
        /// <summary>Indicates no special actions needed for move.</summary>
        JsTTDMoveNone = 0,
        /// <summary>Indicates that we want to move to the first event.</summary>
        JsTTDMoveFirstEvent = 1,
        /// <summary>Indicates that we want to move to the last event.</summary>
        JsTTDMoveLastEvent = 2,
        /// <summary>Indicates that we want to move to the kth event -- top 32 bits are event count.</summary>
        JsTTDMoveKthEvent = 4,
        /// <summary>Indicates if we are doing the scan for a continue operation</summary>
        JsTTDMoveScanIntervalForContinue = 16,
        /// <summary>Indicates if we want to set break on entry or just run and let something else trigger breakpoints.</summary>
        JsTTDMoveBreakOnEntry = 256
    }

    /// <summary>
    /// <para>User implemented callback routine for debug events.</para>
    /// </summary>
    /// <remarks>
    /// <para>Use JsDiagStartDebugging to register the callback.</para>
    /// </remarks>
    /// <param name="debugEvent">
    /// <para>The type of JsDiagDebugEvent event.</para>
    /// </param>
    /// <param name="eventData">
    /// <para>Additional data related to the debug event.</para>
    /// </param>
    /// <param name="callbackState">
    /// <para>The state passed to JsDiagStartDebugging.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void JsDiagDebugEventCallback(_JsDiagDebugEvent debugEvent, global::System.IntPtr eventData, global::System.IntPtr callbackState);

    /// <summary>
    /// <para>A handle for URI's that TTD information is written to/read from.</para>
    /// </summary>
    public class JsTTDStreamHandle { }

    /// <summary>
    /// <para>TTD API -- may change in future versions:     Ensure that the location specified for outputting the TTD data is clean. Specifically, ensure that any previous TTD     in the location has been removed.</para>
    /// </summary>
    /// <param name="uriByteLength">
    /// <para>The length of the uriBytes array that the host passed in for storing log info.</para>
    /// </param>
    /// <param name="uriBytes">
    /// <para>The bytes of the URI that the host passed in for storing log info.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void JsTTDInitializeForWriteLogStreamCallback(ulong uriByteLength, byte* uriBytes);

    /// <summary>
    /// <para>TTD API -- may change in future versions:     Construct a JsTTDStreamHandle that will be used to read/write the event log portion of the TTD data based on the uri     provided by JsTTDInitializeUriCallback.</para>
    /// </summary>
    /// <remarks>
    /// <para>Exactly one of read or write will be set to true.</para>
    /// </remarks>
    /// <param name="uriByteLength">
    /// <para>The length of the uriBytes array that the host passed in for storing log info.</para>
    /// </param>
    /// <param name="uriBytes">
    /// <para>The bytes of the URI that the host passed in for storing log info.</para>
    /// </param>
    /// <param name="asciiResourceName">
    /// <para>A null terminated ascii string giving a unique name to the resource that the JsTTDStreamHandle will be created for.</para>
    /// </param>
    /// <param name="read">
    /// <para>If the handle should be opened for reading.</para>
    /// </param>
    /// <param name="write">
    /// <para>If the handle should be opened for writing.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate global::System.IntPtr TTDOpenResourceStreamCallback(ulong uriByteLength, byte* uriBytes, [MarshalAs(UnmanagedType.LPStr)] string asciiResourceName, bool read, bool write, byte** relocatedUri, ulong* relocatedUriLength);

    /// <summary>
    /// <para>TTD API -- may change in future versions:     A callback for reading data from a handle.</para>
    /// </summary>
    /// <param name="handle">
    /// <para>The JsTTDStreamHandle to read the data from.</para>
    /// </param>
    /// <param name="buff">
    /// <para>The buffer to place the data into.</para>
    /// </param>
    /// <param name="size">
    /// <para>The max number of bytes that should be read.</para>
    /// </param>
    /// <param name="readCount">
    /// <para>The actual number of bytes read and placed in the buffer.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate bool JsTTDReadBytesFromStreamCallback(global::System.IntPtr handle, byte* buff, ulong size, ulong* readCount);

    /// <summary>
    /// <para>TTD API -- may change in future versions:     A callback for writing data to a handle.</para>
    /// </summary>
    /// <param name="handle">
    /// <para>The JsTTDStreamHandle to write the data to.</para>
    /// </param>
    /// <param name="buff">
    /// <para>The buffer to copy the data from.</para>
    /// </param>
    /// <param name="size">
    /// <para>The max number of bytes that should be written.</para>
    /// </param>
    /// <param name="readCount">
    /// <para>The actual number of bytes written to the HANDLE.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate bool JsTTDWriteBytesToStreamCallback(global::System.IntPtr handle, byte* buff, ulong size, ulong* writtenCount);

    /// <summary>
    /// <para>TTD API -- may change in future versions:     Flush and close the stream represented by the HANDLE as needed.</para>
    /// </summary>
    /// <remarks>
    /// <para>Exactly one of read or write will be set to true.</para>
    /// </remarks>
    /// <param name="handle">
    /// <para>The JsTTDStreamHandle to close.</para>
    /// </param>
    /// <param name="read">
    /// <para>If the handle was opened for reading.</para>
    /// </param>
    /// <param name="write">
    /// <para>If the handle was opened for writing.</para>
    /// </param>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
    public unsafe delegate void JsTTDFlushAndCloseStreamCallback(global::System.IntPtr handle, bool read, bool write);

    public unsafe partial class ChakraDebug
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagStartDebugging")]
            internal static extern _JsErrorCode JsDiagStartDebugging_0(global::System.IntPtr runtimeHandle, global::System.IntPtr debugEventCallback, global::System.IntPtr callbackState);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagStopDebugging")]
            internal static extern _JsErrorCode JsDiagStopDebugging_0(global::System.IntPtr runtimeHandle, global::System.IntPtr* callbackState);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagRequestAsyncBreak")]
            internal static extern _JsErrorCode JsDiagRequestAsyncBreak_0(global::System.IntPtr runtimeHandle);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagGetBreakpoints")]
            internal static extern _JsErrorCode JsDiagGetBreakpoints_0(global::System.IntPtr* breakpoints);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagSetBreakpoint")]
            internal static extern _JsErrorCode JsDiagSetBreakpoint_0(uint scriptId, uint lineNumber, uint columnNumber, global::System.IntPtr* breakpoint);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagRemoveBreakpoint")]
            internal static extern _JsErrorCode JsDiagRemoveBreakpoint_0(uint breakpointId);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagSetBreakOnException")]
            internal static extern _JsErrorCode JsDiagSetBreakOnException_0(global::System.IntPtr runtimeHandle, _JsDiagBreakOnExceptionAttributes exceptionAttributes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagGetBreakOnException")]
            internal static extern _JsErrorCode JsDiagGetBreakOnException_0(global::System.IntPtr runtimeHandle, _JsDiagBreakOnExceptionAttributes* exceptionAttributes);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagSetStepType")]
            internal static extern _JsErrorCode JsDiagSetStepType_0(_JsDiagStepType stepType);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagGetScripts")]
            internal static extern _JsErrorCode JsDiagGetScripts_0(global::System.IntPtr* scriptsArray);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagGetSource")]
            internal static extern _JsErrorCode JsDiagGetSource_0(uint scriptId, global::System.IntPtr* source);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagGetFunctionPosition")]
            internal static extern _JsErrorCode JsDiagGetFunctionPosition_0(global::System.IntPtr function, global::System.IntPtr* functionPosition);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagGetStackTrace")]
            internal static extern _JsErrorCode JsDiagGetStackTrace_0(global::System.IntPtr* stackTrace);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagGetStackProperties")]
            internal static extern _JsErrorCode JsDiagGetStackProperties_0(uint stackFrameIndex, global::System.IntPtr* properties);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagGetProperties")]
            internal static extern _JsErrorCode JsDiagGetProperties_0(uint objectHandle, uint fromCount, uint totalCount, global::System.IntPtr* propertiesObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagGetObjectFromHandle")]
            internal static extern _JsErrorCode JsDiagGetObjectFromHandle_0(uint objectHandle, global::System.IntPtr* handleObject);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsDiagEvaluate")]
            internal static extern _JsErrorCode JsDiagEvaluate_0(global::System.IntPtr expression, uint stackFrameIndex, _JsParseScriptAttributes parseAttributes, global::System.IntPtr* evalResult);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDCreateRecordRuntime")]
            internal static extern _JsErrorCode JsTTDCreateRecordRuntime_0(_JsRuntimeAttributes attributes, byte* infoUri, ulong infoUriCount, ulong snapInterval, ulong snapHistoryLength, global::System.IntPtr writeInitializeFunction, global::System.IntPtr openResourceStream, global::System.IntPtr readBytesFromStream, global::System.IntPtr writeBytesToStream, global::System.IntPtr flushAndCloseStream, global::System.IntPtr threadService, global::System.IntPtr* runtime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDCreateReplayRuntime")]
            internal static extern _JsErrorCode JsTTDCreateReplayRuntime_0(_JsRuntimeAttributes attributes, byte* infoUri, ulong infoUriCount, bool enableDebugging, global::System.IntPtr writeInitializeFunction, global::System.IntPtr openResourceStream, global::System.IntPtr readBytesFromStream, global::System.IntPtr writeBytesToStream, global::System.IntPtr flushAndCloseStream, global::System.IntPtr threadService, global::System.IntPtr* runtime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDCreateContext")]
            internal static extern _JsErrorCode JsTTDCreateContext_0(global::System.IntPtr runtimeHandle, bool useRuntimeTTDMode, global::System.IntPtr* newContext);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDNotifyContextDestroy")]
            internal static extern _JsErrorCode JsTTDNotifyContextDestroy_0(global::System.IntPtr context);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDStart")]
            internal static extern _JsErrorCode JsTTDStart_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDStop")]
            internal static extern _JsErrorCode JsTTDStop_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDEmitRecording")]
            internal static extern _JsErrorCode JsTTDEmitRecording_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDPauseTimeTravelBeforeRuntimeOperation")]
            internal static extern _JsErrorCode JsTTDPauseTimeTravelBeforeRuntimeOperation_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDReStartTimeTravelAfterRuntimeOperation")]
            internal static extern _JsErrorCode JsTTDReStartTimeTravelAfterRuntimeOperation_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDNotifyYield")]
            internal static extern _JsErrorCode JsTTDNotifyYield_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDHostExit")]
            internal static extern _JsErrorCode JsTTDHostExit_0(int statusCode);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDRawBufferCopySyncIndirect")]
            internal static extern _JsErrorCode JsTTDRawBufferCopySyncIndirect_0(global::System.IntPtr dst, ulong dstIndex, global::System.IntPtr src, ulong srcIndex, ulong count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDRawBufferModifySyncIndirect")]
            internal static extern _JsErrorCode JsTTDRawBufferModifySyncIndirect_0(global::System.IntPtr buffer, ulong index, ulong count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDRawBufferAsyncModificationRegister")]
            internal static extern _JsErrorCode JsTTDRawBufferAsyncModificationRegister_0(global::System.IntPtr instance, byte* initialModPos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDRawBufferAsyncModifyComplete")]
            internal static extern _JsErrorCode JsTTDRawBufferAsyncModifyComplete_0(byte* finalModPos);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDCheckAndAssertIfTTDRunning")]
            internal static extern _JsErrorCode JsTTDCheckAndAssertIfTTDRunning_0([MarshalAs(UnmanagedType.LPStr)] string msg);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDGetSnapTimeTopLevelEventMove")]
            internal static extern _JsErrorCode JsTTDGetSnapTimeTopLevelEventMove_0(global::System.IntPtr runtimeHandle, _JsTTDMoveModes moveMode, uint kthEvent, long* targetEventTime, int* targetStartSnapTime, int* targetEndSnapTime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDGetSnapShotBoundInterval")]
            internal static extern _JsErrorCode JsTTDGetSnapShotBoundInterval_0(global::System.IntPtr runtimeHandle, long targetEventTime, int* startSnapTime, int* endSnapTime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDGetPreviousSnapshotInterval")]
            internal static extern _JsErrorCode JsTTDGetPreviousSnapshotInterval_0(global::System.IntPtr runtimeHandle, long currentSnapStartTime, int* previousSnapTime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDPreExecuteSnapShotInterval")]
            internal static extern _JsErrorCode JsTTDPreExecuteSnapShotInterval_0(global::System.IntPtr runtimeHandle, long startSnapTime, long endSnapTime, _JsTTDMoveModes moveMode, int* newTargetEventTime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDMoveToTopLevelEvent")]
            internal static extern _JsErrorCode JsTTDMoveToTopLevelEvent_0(global::System.IntPtr runtimeHandle, _JsTTDMoveModes moveMode, long snapshotTime, long eventTime);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ChakraCore", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint = "JsTTDReplayExecution")]
            internal static extern _JsErrorCode JsTTDReplayExecution_0(_JsTTDMoveModes* moveMode, int* rootEventTime);
        }

        /// <summary>
        /// <para>Starts debugging in the given runtime.</para>
        /// </summary>
        /// <remarks>
        /// <para>The runtime should be active on the current thread and should not be in debug state.</para>
        /// </remarks>
        /// <param name="runtimeHandle">
        /// <para>Runtime to put into debug mode.</para>
        /// </param>
        /// <param name="debugEventCallback">
        /// <para>Registers a callback to be called on every JsDiagDebugEvent.</para>
        /// </param>
        /// <param name="callbackState">
        /// <para>User provided state that will be passed back to the callback.</para>
        /// </param>
        public static _JsErrorCode JsDiagStartDebugging(global::System.IntPtr runtimeHandle, JsDiagDebugEventCallback debugEventCallback, global::System.IntPtr callbackState)
        {
            var __arg1 = debugEventCallback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(debugEventCallback);
            var __ret = __Internal.JsDiagStartDebugging_0(runtimeHandle, __arg1, callbackState);
            return __ret;
        }

        /// <summary>
        /// <para>Stops debugging in the given runtime.</para>
        /// </summary>
        /// <remarks>
        /// <para>The runtime should be active on the current thread and in debug state.</para>
        /// </remarks>
        /// <param name="runtimeHandle">
        /// <para>Runtime to stop debugging.</para>
        /// </param>
        /// <param name="callbackState">
        /// <para>User provided state that was passed in JsDiagStartDebugging.</para>
        /// </param>
        public static _JsErrorCode JsDiagStopDebugging(global::System.IntPtr runtimeHandle, out global::System.IntPtr callbackState)
        {
            global::System.IntPtr _callbackState;
            var __arg1 = &_callbackState;
            var __ret = __Internal.JsDiagStopDebugging_0(runtimeHandle, __arg1);
            callbackState = _callbackState;
            return __ret;
        }

        /// <summary>
        /// <para>Request the runtime to break on next JavaScript statement.</para>
        /// </summary>
        /// <remarks>
        /// <para>The runtime should be in debug state. This API can be called from another runtime.</para>
        /// </remarks>
        /// <param name="runtimeHandle">
        /// <para>Runtime to request break.</para>
        /// </param>
        public static _JsErrorCode JsDiagRequestAsyncBreak(global::System.IntPtr runtimeHandle)
        {
            var __ret = __Internal.JsDiagRequestAsyncBreak_0(runtimeHandle);
            return __ret;
        }

        /// <summary>
        /// <para>List all breakpoints in the current runtime.</para>
        /// </summary>
        /// <remarks>
        /// <para>[{</para>
        /// <para>&quot;breakpointId&quot; : 1,</para>
        /// <para>&quot;scriptId&quot; : 1,</para>
        /// <para>&quot;line&quot; : 0,</para>
        /// <para>&quot;column&quot; : 62</para>
        /// <para>}]</para>
        /// </remarks>
        /// <param name="breakpoints">
        /// <para>Array of breakpoints.</para>
        /// </param>
        public static _JsErrorCode JsDiagGetBreakpoints(out global::System.IntPtr breakpoints)
        {
            global::System.IntPtr _breakpoints;
            var __arg0 = &_breakpoints;
            var __ret = __Internal.JsDiagGetBreakpoints_0(__arg0);
            breakpoints = _breakpoints;
            return __ret;
        }

        /// <summary>
        /// <para>Sets breakpoint in the specified script at give location.</para>
        /// </summary>
        /// <remarks>
        /// <para>{</para>
        /// <para>&quot;breakpointId&quot; : 1,</para>
        /// <para>&quot;line&quot; : 2,</para>
        /// <para>&quot;column&quot; : 4</para>
        /// <para>}</para>
        /// </remarks>
        /// <param name="scriptId">
        /// <para>Id of script from JsDiagGetScripts or JsDiagGetSource to put breakpoint.</para>
        /// </param>
        /// <param name="lineNumber">
        /// <para>0 based line number to put breakpoint.</para>
        /// </param>
        /// <param name="columnNumber">
        /// <para>0 based column number to put breakpoint.</para>
        /// </param>
        /// <param name="breakpoint">
        /// <para>Breakpoint object with id, line and column if success.</para>
        /// </param>
        public static _JsErrorCode JsDiagSetBreakpoint(uint scriptId, uint lineNumber, uint columnNumber, out global::System.IntPtr breakpoint)
        {
            global::System.IntPtr _breakpoint;
            var __arg3 = &_breakpoint;
            var __ret = __Internal.JsDiagSetBreakpoint_0(scriptId, lineNumber, columnNumber, __arg3);
            breakpoint = _breakpoint;
            return __ret;
        }

        /// <summary>
        /// <para>Remove a breakpoint.</para>
        /// </summary>
        /// <remarks>
        /// <para>The current runtime should be in debug state. This API can be called when runtime is at a break or running.</para>
        /// </remarks>
        /// <param name="breakpointId">
        /// <para>Breakpoint id returned from JsDiagSetBreakpoint.</para>
        /// </param>
        public static _JsErrorCode JsDiagRemoveBreakpoint(uint breakpointId)
        {
            var __ret = __Internal.JsDiagRemoveBreakpoint_0(breakpointId);
            return __ret;
        }

        /// <summary>
        /// <para>Sets break on exception handling.</para>
        /// </summary>
        /// <remarks>
        /// <para>If this API is not called the default value is set to JsDiagBreakOnExceptionAttributeUncaught in the runtime.</para>
        /// </remarks>
        /// <param name="runtimeHandle">
        /// <para>Runtime to set break on exception attributes.</para>
        /// </param>
        /// <param name="exceptionAttributes">
        /// <para>Mask of JsDiagBreakOnExceptionAttributes to set.</para>
        /// </param>
        public static _JsErrorCode JsDiagSetBreakOnException(global::System.IntPtr runtimeHandle, _JsDiagBreakOnExceptionAttributes exceptionAttributes)
        {
            var __ret = __Internal.JsDiagSetBreakOnException_0(runtimeHandle, exceptionAttributes);
            return __ret;
        }

        /// <summary>
        /// <para>Gets break on exception setting.</para>
        /// </summary>
        /// <remarks>
        /// <para>The runtime should be in debug state. This API can be called from another runtime.</para>
        /// </remarks>
        /// <param name="runtimeHandle">
        /// <para>Runtime from which to get break on exception attributes, should be in debug mode.</para>
        /// </param>
        /// <param name="exceptionAttributes">
        /// <para>Mask of JsDiagBreakOnExceptionAttributes.</para>
        /// </param>
        public static _JsErrorCode JsDiagGetBreakOnException(global::System.IntPtr runtimeHandle, out _JsDiagBreakOnExceptionAttributes exceptionAttributes)
        {
            _JsDiagBreakOnExceptionAttributes _exceptionAttributes;
            var __arg1 = &_exceptionAttributes;
            var __ret = __Internal.JsDiagGetBreakOnException_0(runtimeHandle, __arg1);
            exceptionAttributes = _exceptionAttributes;
            return __ret;
        }

        /// <summary>
        /// <para>Sets the step type in the runtime after a debug break.</para>
        /// </summary>
        /// <remarks>
        /// <para>Requires to be at a debug break.</para>
        /// </remarks>
        /// <param name="resumeType">
        /// <para>Type of JsDiagStepType.</para>
        /// </param>
        public static _JsErrorCode JsDiagSetStepType(_JsDiagStepType stepType)
        {
            var __ret = __Internal.JsDiagSetStepType_0(stepType);
            return __ret;
        }

        /// <summary>
        /// <para>Gets list of scripts.</para>
        /// </summary>
        /// <remarks>
        /// <para>[{</para>
        /// <para>&quot;scriptId&quot; : 2,</para>
        /// <para>&quot;fileName&quot; : &quot;c:\\Test\\Test.js&quot;,</para>
        /// <para>&quot;lineCount&quot; : 4,</para>
        /// <para>&quot;sourceLength&quot; : 111</para>
        /// <para>}, {</para>
        /// <para>&quot;scriptId&quot; : 3,</para>
        /// <para>&quot;parentScriptId&quot; : 2,</para>
        /// <para>&quot;scriptType&quot; : &quot;eval code&quot;,</para>
        /// <para>&quot;lineCount&quot; : 1,</para>
        /// <para>&quot;sourceLength&quot; : 12</para>
        /// <para>}]</para>
        /// </remarks>
        /// <param name="scriptsArray">
        /// <para>Array of script objects.</para>
        /// </param>
        public static _JsErrorCode JsDiagGetScripts(out global::System.IntPtr scriptsArray)
        {
            global::System.IntPtr _scriptsArray;
            var __arg0 = &_scriptsArray;
            var __ret = __Internal.JsDiagGetScripts_0(__arg0);
            scriptsArray = _scriptsArray;
            return __ret;
        }

        /// <summary>
        /// <para>Gets source for a specific script identified by scriptId from JsDiagGetScripts.</para>
        /// </summary>
        /// <remarks>
        /// <para>{</para>
        /// <para>&quot;scriptId&quot; : 1,</para>
        /// <para>&quot;fileName&quot; : &quot;c:\\Test\\Test.js&quot;,</para>
        /// <para>&quot;lineCount&quot; : 12,</para>
        /// <para>&quot;sourceLength&quot; : 15154,</para>
        /// <para>&quot;source&quot; : &quot;var x = 1;&quot;</para>
        /// <para>}</para>
        /// </remarks>
        /// <param name="scriptId">
        /// <para>Id of the script.</para>
        /// </param>
        /// <param name="source">
        /// <para>Source object.</para>
        /// </param>
        public static _JsErrorCode JsDiagGetSource(uint scriptId, out global::System.IntPtr source)
        {
            global::System.IntPtr _source;
            var __arg1 = &_source;
            var __ret = __Internal.JsDiagGetSource_0(scriptId, __arg1);
            source = _source;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the source information for a function object.</para>
        /// </summary>
        /// <remarks>
        /// <para>{</para>
        /// <para>&quot;scriptId&quot; : 1,</para>
        /// <para>&quot;fileName&quot; : &quot;c:\\Test\\Test.js&quot;,</para>
        /// <para>&quot;line&quot; : 1,</para>
        /// <para>&quot;column&quot; : 2,</para>
        /// <para>&quot;firstStatementLine&quot; : 6,</para>
        /// <para>&quot;firstStatementColumn&quot; : 0</para>
        /// <para>}</para>
        /// </remarks>
        /// <param name="function">
        /// <para>JavaScript function.</para>
        /// </param>
        /// <param name="functionPosition">
        /// <para>Function position - scriptId, start line, start column, line number of first statement, column number of first statement.</para>
        /// </param>
        public static _JsErrorCode JsDiagGetFunctionPosition(global::System.IntPtr function, out global::System.IntPtr functionPosition)
        {
            global::System.IntPtr _functionPosition;
            var __arg1 = &_functionPosition;
            var __ret = __Internal.JsDiagGetFunctionPosition_0(function, __arg1);
            functionPosition = _functionPosition;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the stack trace information.</para>
        /// </summary>
        /// <remarks>
        /// <para>[{</para>
        /// <para>&quot;index&quot; : 0,</para>
        /// <para>&quot;scriptId&quot; : 2,</para>
        /// <para>&quot;line&quot; : 3,</para>
        /// <para>&quot;column&quot; : 0,</para>
        /// <para>&quot;sourceLength&quot; : 9,</para>
        /// <para>&quot;sourceText&quot; : &quot;var x = 1&quot;,</para>
        /// <para>&quot;functionHandle&quot; : 1</para>
        /// <para>}]</para>
        /// </remarks>
        /// <param name="stackTrace">
        /// <para>Stack trace information.</para>
        /// </param>
        public static _JsErrorCode JsDiagGetStackTrace(out global::System.IntPtr stackTrace)
        {
            global::System.IntPtr _stackTrace;
            var __arg0 = &_stackTrace;
            var __ret = __Internal.JsDiagGetStackTrace_0(__arg0);
            stackTrace = _stackTrace;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the list of properties corresponding to the frame.</para>
        /// </summary>
        /// <remarks>
        /// <para>propertyAttributes is a bit mask of</para>
        /// <para>NONE = 0x1,</para>
        /// <para>HAVE_CHILDRENS = 0x2,</para>
        /// <para>READ_ONLY_VALUE = 0x4,</para>
        /// <para></para>
        /// <para>{</para>
        /// <para>&quot;thisObject&quot;: {</para>
        /// <para>&quot;name&quot;: &quot;this&quot;,</para>
        /// <para>&quot;type&quot; : &quot;object&quot;,</para>
        /// <para>&quot;className&quot; : &quot;Object&quot;,</para>
        /// <para>&quot;display&quot; : &quot;{...}&quot;,</para>
        /// <para>&quot;propertyAttributes&quot; : 1,</para>
        /// <para>&quot;handle&quot; : 306</para>
        /// <para>},</para>
        /// <para>&quot;exception&quot; : {</para>
        /// <para>&quot;name&quot; : &quot;{exception}&quot;,</para>
        /// <para>&quot;type&quot; : &quot;object&quot;,</para>
        /// <para>&quot;display&quot; : &quot;'a' is undefined&quot;,</para>
        /// <para>&quot;className&quot; : &quot;Error&quot;,</para>
        /// <para>&quot;propertyAttributes&quot; : 1,</para>
        /// <para>&quot;handle&quot; : 307</para>
        /// <para>}</para>
        /// <para>&quot;arguments&quot; : {</para>
        /// <para>&quot;name&quot; : &quot;arguments&quot;,</para>
        /// <para>&quot;type&quot; : &quot;object&quot;,</para>
        /// <para>&quot;display&quot; : &quot;{...}&quot;,</para>
        /// <para>&quot;className&quot; : &quot;Object&quot;,</para>
        /// <para>&quot;propertyAttributes&quot; : 1,</para>
        /// <para>&quot;handle&quot; : 190</para>
        /// <para>},</para>
        /// <para>&quot;returnValue&quot; : {</para>
        /// <para>&quot;name&quot; : &quot;[Return value]&quot;,</para>
        /// <para>&quot;type&quot; : &quot;undefined&quot;,</para>
        /// <para>&quot;propertyAttributes&quot; : 0,</para>
        /// <para>&quot;handle&quot; : 192</para>
        /// <para>},</para>
        /// <para>&quot;functionCallsReturn&quot; : [{</para>
        /// <para>&quot;name&quot; : &quot;[foo1 returned]&quot;,</para>
        /// <para>&quot;type&quot; : &quot;number&quot;,</para>
        /// <para>&quot;value&quot; : 1,</para>
        /// <para>&quot;propertyAttributes&quot; : 2,</para>
        /// <para>&quot;handle&quot; : 191</para>
        /// <para>}</para>
        /// <para>],</para>
        /// <para>&quot;locals&quot; : [],</para>
        /// <para>&quot;scopes&quot; : [{</para>
        /// <para>&quot;index&quot; : 0,</para>
        /// <para>&quot;handle&quot; : 193</para>
        /// <para>}</para>
        /// <para>],</para>
        /// <para>&quot;globals&quot; : {</para>
        /// <para>&quot;handle&quot; : 194</para>
        /// <para>}</para>
        /// <para>}</para>
        /// </remarks>
        /// <param name="stackFrameIndex">
        /// <para>Index of stack frame from JsDiagGetStackTrace.</para>
        /// </param>
        /// <param name="properties">
        /// <para>Object of properties array (properties, scopes and globals).</para>
        /// </param>
        public static _JsErrorCode JsDiagGetStackProperties(uint stackFrameIndex, out global::System.IntPtr properties)
        {
            global::System.IntPtr _properties;
            var __arg1 = &_properties;
            var __ret = __Internal.JsDiagGetStackProperties_0(stackFrameIndex, __arg1);
            properties = _properties;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the list of children of a handle.</para>
        /// </summary>
        /// <remarks>
        /// <para>Handle should be from objects returned from call to JsDiagGetStackProperties.</para>
        /// </remarks>
        /// <param name="objectHandle">
        /// <para>Handle of object.</para>
        /// </param>
        /// <param name="fromCount">
        /// <para>0-based from count of properties, usually 0.</para>
        /// </param>
        /// <param name="totalCount">
        /// <para>Number of properties to return.</para>
        /// </param>
        /// <param name="propertiesObject">
        /// <para>Array of properties.</para>
        /// </param>
        public static _JsErrorCode JsDiagGetProperties(uint objectHandle, uint fromCount, uint totalCount, out global::System.IntPtr propertiesObject)
        {
            global::System.IntPtr _propertiesObject;
            var __arg3 = &_propertiesObject;
            var __ret = __Internal.JsDiagGetProperties_0(objectHandle, fromCount, totalCount, __arg3);
            propertiesObject = _propertiesObject;
            return __ret;
        }

        /// <summary>
        /// <para>Gets the object corresponding to handle.</para>
        /// </summary>
        /// <remarks>
        /// <para>{</para>
        /// <para>&quot;scriptId&quot; : 24,</para>
        /// <para>&quot;line&quot; : 1,</para>
        /// <para>&quot;column&quot; : 63,</para>
        /// <para>&quot;name&quot; : &quot;foo&quot;,</para>
        /// <para>&quot;type&quot; : &quot;function&quot;,</para>
        /// <para>&quot;handle&quot; : 2</para>
        /// <para>}</para>
        /// </remarks>
        /// <param name="objectHandle">
        /// <para>Handle of object.</para>
        /// </param>
        /// <param name="handleObject">
        /// <para>Object corresponding to the handle.</para>
        /// </param>
        public static _JsErrorCode JsDiagGetObjectFromHandle(uint objectHandle, out global::System.IntPtr handleObject)
        {
            global::System.IntPtr _handleObject;
            var __arg1 = &_handleObject;
            var __ret = __Internal.JsDiagGetObjectFromHandle_0(objectHandle, __arg1);
            handleObject = _handleObject;
            return __ret;
        }

        /// <summary>
        /// <para>Evaluates an expression on given frame.</para>
        /// </summary>
        /// <remarks>
        /// <para>evalResult when evaluating 'this' and return is JsNoError</para>
        /// <para>{</para>
        /// <para>&quot;name&quot; : &quot;this&quot;,</para>
        /// <para>&quot;type&quot; : &quot;object&quot;,</para>
        /// <para>&quot;className&quot; : &quot;Object&quot;,</para>
        /// <para>&quot;display&quot; : &quot;{...}&quot;,</para>
        /// <para>&quot;propertyAttributes&quot; : 1,</para>
        /// <para>&quot;handle&quot; : 18</para>
        /// <para>}</para>
        /// <para></para>
        /// <para>evalResult when evaluating a script which throws JavaScript error and return is JsErrorScriptException</para>
        /// <para>{</para>
        /// <para>&quot;name&quot; : &quot;a.b.c&quot;,</para>
        /// <para>&quot;type&quot; : &quot;object&quot;,</para>
        /// <para>&quot;className&quot; : &quot;Error&quot;,</para>
        /// <para>&quot;display&quot; : &quot;'a' is undefined&quot;,</para>
        /// <para>&quot;propertyAttributes&quot; : 1,</para>
        /// <para>&quot;handle&quot; : 18</para>
        /// <para>}</para>
        /// </remarks>
        /// <param name="expression">
        /// <para>Javascript String or ArrayBuffer (incl. ExternalArrayBuffer).</para>
        /// </param>
        /// <param name="stackFrameIndex">
        /// <para>Index of stack frame on which to evaluate the expression.</para>
        /// </param>
        /// <param name="parseAttributes">
        /// <para>Defines how `expression` (JsValueRef) should be parsed. - `JsParseScriptAttributeNone` when `expression` is a Utf8 encoded ArrayBuffer and/or a Javascript String (encoding independent) - `JsParseScriptAttributeArrayBufferIsUtf16Encoded` when `expression` is Utf16 Encoded ArrayBuffer - `JsParseScriptAttributeLibraryCode` has no use for this function and has similar effect with `JsParseScriptAttributeNone`</para>
        /// </param>
        /// <param name="evalResult">
        /// <para>Result of evaluation.</para>
        /// </param>
        public static _JsErrorCode JsDiagEvaluate(global::System.IntPtr expression, uint stackFrameIndex, _JsParseScriptAttributes parseAttributes, out global::System.IntPtr evalResult)
        {
            global::System.IntPtr _evalResult;
            var __arg3 = &_evalResult;
            var __ret = __Internal.JsDiagEvaluate_0(expression, stackFrameIndex, parseAttributes, __arg3);
            evalResult = _evalResult;
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Creates a new runtime in Record Mode.</para>
        /// </summary>
        /// <remarks>
        /// <para>See JsCreateRuntime for additional information.</para>
        /// </remarks>
        /// <param name="attributes">
        /// <para>The attributes of the runtime to be created.</para>
        /// </param>
        /// <param name="infoUri">
        /// <para>The uri where the recorded Time-Travel data should be stored.</para>
        /// </param>
        /// <param name="snapInterval">
        /// <para>The interval to wait between snapshots (measured in millis).</para>
        /// </param>
        /// <param name="snapHistoryLength">
        /// <para>The amount of history to maintain before discarding -- measured in number of snapshots and controls how far back in time a trace can be reversed.</para>
        /// </param>
        /// <param name="writeInitializeFunction">
        /// <para>The JsTTDInitializeForWriteLogStreamCallback function for performing any initialization needed prepare uri for storing time travel recording data.</para>
        /// </param>
        /// <param name="openResourceStream">
        /// <para>The TTDOpenResourceStreamCallback function for generating a JsTTDStreamHandle to read/write serialized data.</para>
        /// </param>
        /// <param name="readBytesFromStream">
        /// <para>The JsTTDReadBytesFromStreamCallback function for reading bytes from a JsTTDStreamHandle.</para>
        /// </param>
        /// <param name="writeBytesToStream">
        /// <para>The JsTTDWriteBytesToStreamCallback function for writing bytes to a JsTTDStreamHandle.</para>
        /// </param>
        /// <param name="flushAndCloseStream">
        /// <para>The JsTTDFlushAndCloseStreamCallback function for flushing and closing a JsTTDStreamHandle as needed.</para>
        /// </param>
        /// <param name="threadService">
        /// <para>The thread service for the runtime. Can be null.</para>
        /// </param>
        /// <param name="runtime">
        /// <para>The runtime created.</para>
        /// </param>
        public static _JsErrorCode JsTTDCreateRecordRuntime(_JsRuntimeAttributes attributes, byte* infoUri, ulong infoUriCount, ulong snapInterval, ulong snapHistoryLength, JsTTDInitializeForWriteLogStreamCallback writeInitializeFunction, TTDOpenResourceStreamCallback openResourceStream, JsTTDReadBytesFromStreamCallback readBytesFromStream, JsTTDWriteBytesToStreamCallback writeBytesToStream, JsTTDFlushAndCloseStreamCallback flushAndCloseStream, JsThreadServiceCallback threadService, out global::System.IntPtr runtime)
        {
            var __arg5 = writeInitializeFunction == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(writeInitializeFunction);
            var __arg6 = openResourceStream == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(openResourceStream);
            var __arg7 = readBytesFromStream == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(readBytesFromStream);
            var __arg8 = writeBytesToStream == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(writeBytesToStream);
            var __arg9 = flushAndCloseStream == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(flushAndCloseStream);
            var __arg10 = threadService == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(threadService);
            global::System.IntPtr _runtime;
            var __arg11 = &_runtime;
            var __ret = __Internal.JsTTDCreateRecordRuntime_0(attributes, infoUri, infoUriCount, snapInterval, snapHistoryLength, __arg5, __arg6, __arg7, __arg8, __arg9, __arg10, __arg11);
            runtime = _runtime;
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Creates a new runtime in Debug Mode.</para>
        /// </summary>
        /// <remarks>
        /// <para>See JsCreateRuntime for additional information.</para>
        /// </remarks>
        /// <param name="attributes">
        /// <para>The attributes of the runtime to be created.</para>
        /// </param>
        /// <param name="infoUri">
        /// <para>The uri where the recorded Time-Travel data should be loaded from.</para>
        /// </param>
        /// <param name="enableDebugging">
        /// <para>A flag to enable addtional debugging operation support during replay.</para>
        /// </param>
        /// <param name="writeInitializeFunction">
        /// <para>The JsTTDInitializeForWriteLogStreamCallback function for performing any initialization needed prepare uri for storing time travel recording data.</para>
        /// </param>
        /// <param name="openResourceStream">
        /// <para>The TTDOpenResourceStreamCallback function for generating a JsTTDStreamHandle to read/write serialized data.</para>
        /// </param>
        /// <param name="readBytesFromStream">
        /// <para>The JsTTDReadBytesFromStreamCallback function for reading bytes from a JsTTDStreamHandle.</para>
        /// </param>
        /// <param name="writeBytesToStream">
        /// <para>The JsTTDWriteBytesToStreamCallback function for writing bytes to a JsTTDStreamHandle.</para>
        /// </param>
        /// <param name="flushAndCloseStream">
        /// <para>The JsTTDFlushAndCloseStreamCallback function for flushing and closing a JsTTDStreamHandle as needed.</para>
        /// </param>
        /// <param name="threadService">
        /// <para>The thread service for the runtime. Can be null.</para>
        /// </param>
        /// <param name="runtime">
        /// <para>The runtime created.</para>
        /// </param>
        public static _JsErrorCode JsTTDCreateReplayRuntime(_JsRuntimeAttributes attributes, byte* infoUri, ulong infoUriCount, bool enableDebugging, JsTTDInitializeForWriteLogStreamCallback writeInitializeFunction, TTDOpenResourceStreamCallback openResourceStream, JsTTDReadBytesFromStreamCallback readBytesFromStream, JsTTDWriteBytesToStreamCallback writeBytesToStream, JsTTDFlushAndCloseStreamCallback flushAndCloseStream, JsThreadServiceCallback threadService, out global::System.IntPtr runtime)
        {
            var __arg4 = writeInitializeFunction == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(writeInitializeFunction);
            var __arg5 = openResourceStream == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(openResourceStream);
            var __arg6 = readBytesFromStream == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(readBytesFromStream);
            var __arg7 = writeBytesToStream == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(writeBytesToStream);
            var __arg8 = flushAndCloseStream == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(flushAndCloseStream);
            var __arg9 = threadService == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(threadService);
            global::System.IntPtr _runtime;
            var __arg10 = &_runtime;
            var __ret = __Internal.JsTTDCreateReplayRuntime_0(attributes, infoUri, infoUriCount, enableDebugging, __arg4, __arg5, __arg6, __arg7, __arg8, __arg9, __arg10);
            runtime = _runtime;
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Creates a script context that takes the TTD mode from the log or explicitly is not in TTD mode (regular takes mode from currently active script).</para>
        /// </summary>
        /// <param name="runtime">
        /// <para>The runtime the script context is being created in.</para>
        /// </param>
        /// <param name="useRuntimeTTDMode">
        /// <para>Set to true to use runtime TTD mode false to explicitly be non-TTD context.</para>
        /// </param>
        /// <param name="newContext">
        /// <para>The created script context.</para>
        /// </param>
        public static _JsErrorCode JsTTDCreateContext(global::System.IntPtr runtimeHandle, bool useRuntimeTTDMode, out global::System.IntPtr newContext)
        {
            global::System.IntPtr _newContext;
            var __arg2 = &_newContext;
            var __ret = __Internal.JsTTDCreateContext_0(runtimeHandle, useRuntimeTTDMode, __arg2);
            newContext = _newContext;
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Notify the time-travel system that a context has been identified as dead by the gc (and is being de-allocated).</para>
        /// </summary>
        /// <param name="context">
        /// <para>The script context that is now dead.</para>
        /// </param>
        public static _JsErrorCode JsTTDNotifyContextDestroy(global::System.IntPtr context)
        {
            var __ret = __Internal.JsTTDNotifyContextDestroy_0(context);
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Start Time-Travel Recording.</para>
        /// </summary>
        public static _JsErrorCode JsTTDStart()
        {
            var __ret = __Internal.JsTTDStart_0();
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Stop Time-Travel Recording.</para>
        /// </summary>
        public static _JsErrorCode JsTTDStop()
        {
            var __ret = __Internal.JsTTDStop_0();
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Emit Time-Travel Recording.</para>
        /// </summary>
        public static _JsErrorCode JsTTDEmitRecording()
        {
            var __ret = __Internal.JsTTDEmitRecording_0();
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Pause Time-Travel recording before executing code on behalf of debugger or other diagnostic/telemetry.</para>
        /// </summary>
        public static _JsErrorCode JsTTDPauseTimeTravelBeforeRuntimeOperation()
        {
            var __ret = __Internal.JsTTDPauseTimeTravelBeforeRuntimeOperation_0();
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     ReStart Time-Travel recording after executing code on behalf of debugger or other diagnostic/telemetry.</para>
        /// </summary>
        public static _JsErrorCode JsTTDReStartTimeTravelAfterRuntimeOperation()
        {
            var __ret = __Internal.JsTTDReStartTimeTravelAfterRuntimeOperation_0();
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Notify the Js runtime we are at a safe yield point in the event loop (i.e. no locals on the stack and we can proccess as desired).</para>
        /// </summary>
        public static _JsErrorCode JsTTDNotifyYield()
        {
            var __ret = __Internal.JsTTDNotifyYield_0();
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Notify the Js runtime the host is aborting the process and what the status code is.</para>
        /// </summary>
        /// <param name="statusCode">
        /// <para>The exit status code.</para>
        /// </param>
        public static _JsErrorCode JsTTDHostExit(int statusCode)
        {
            var __ret = __Internal.JsTTDHostExit_0(statusCode);
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Notify the event log that the contents of one buffer have been copied to a second buffer.</para>
        /// </summary>
        /// <param name="dst">
        /// <para>The buffer that was written into.</para>
        /// </param>
        /// <param name="dstIndex">
        /// <para>The first index modified.</para>
        /// </param>
        /// <param name="src">
        /// <para>The buffer that was copied from.</para>
        /// </param>
        /// <param name="srcIndex">
        /// <para>The first index copied.</para>
        /// </param>
        /// <param name="count">
        /// <para>The number of bytes copied.</para>
        /// </param>
        public static _JsErrorCode JsTTDRawBufferCopySyncIndirect(global::System.IntPtr dst, ulong dstIndex, global::System.IntPtr src, ulong srcIndex, ulong count)
        {
            var __ret = __Internal.JsTTDRawBufferCopySyncIndirect_0(dst, dstIndex, src, srcIndex, count);
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Notify the event log that the contents of a naked byte* buffer passed to the host have been modified synchronously.</para>
        /// </summary>
        /// <param name="buffer">
        /// <para>The buffer that was modified.</para>
        /// </param>
        /// <param name="index">
        /// <para>The first index modified.</para>
        /// </param>
        /// <param name="count">
        /// <para>The number of bytes written.</para>
        /// </param>
        public static _JsErrorCode JsTTDRawBufferModifySyncIndirect(global::System.IntPtr buffer, ulong index, ulong count)
        {
            var __ret = __Internal.JsTTDRawBufferModifySyncIndirect_0(buffer, index, count);
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Get info for notifying the TTD system that a raw buffer it shares with the host has been modified.</para>
        /// </summary>
        /// <param name="instance">
        /// <para>The array buffer we want to monitor for contents modification.</para>
        /// </param>
        /// <param name="initialModPos">
        /// <para>The first position in the buffer that may be modified.</para>
        /// </param>
        public static _JsErrorCode JsTTDRawBufferAsyncModificationRegister(global::System.IntPtr instance, byte* initialModPos)
        {
            var __ret = __Internal.JsTTDRawBufferAsyncModificationRegister_0(instance, initialModPos);
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Notify the event log that the contents of a naked byte* buffer passed to the host have been modified asynchronously.</para>
        /// </summary>
        /// <param name="finalModPos">
        /// <para>One past the last modified position in the buffer.</para>
        /// </param>
        public static _JsErrorCode JsTTDRawBufferAsyncModifyComplete(byte* finalModPos)
        {
            var __ret = __Internal.JsTTDRawBufferAsyncModifyComplete_0(finalModPos);
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     A check for unimplmented TTD actions in the host.     This API is a TEMPORARY API while we complete the implementation of TTD support in the Node host and will be deleted once that is complete.</para>
        /// </summary>
        /// <param name="msg">
        /// <para>The message to print if we should be catching this as a TTD operation.</para>
        /// </param>
        public static _JsErrorCode JsTTDCheckAndAssertIfTTDRunning(string msg)
        {
            var __ret = __Internal.JsTTDCheckAndAssertIfTTDRunning_0(msg);
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Before calling JsTTDMoveToTopLevelEvent (which inflates a snapshot and replays) check to see if we want to reset the script context.     We reset the script context if the move will require inflating from a different snapshot that the last one.</para>
        /// </summary>
        /// <param name="runtimeHandle">
        /// <para>The runtime handle that the script is executing in.</para>
        /// </param>
        /// <param name="moveMode">
        /// <para>Flags controlling the way the move it performed and how other parameters are interpreted.</para>
        /// </param>
        /// <param name="kthEvent">
        /// <para>When moveMode == JsTTDMoveKthEvent indicates which event, otherwise this parameter is ignored.</para>
        /// </param>
        /// <param name="targetEventTime">
        /// <para>The event time we want to move to or -1 if not relevant.</para>
        /// </param>
        /// <param name="targetStartSnapTime">
        /// <para>Out parameter with the event time of the snapshot that we should inflate from.</para>
        /// </param>
        /// <param name="targetEndSnapTime">
        /// <para>Optional Out parameter with the snapshot time following the event.</para>
        /// </param>
        public static _JsErrorCode JsTTDGetSnapTimeTopLevelEventMove(global::System.IntPtr runtimeHandle, _JsTTDMoveModes moveMode, uint kthEvent, ref long targetEventTime, out int targetStartSnapTime, out int targetEndSnapTime)
        {
            fixed (long* __refParamPtr3 = &targetEventTime)
            {
                var __arg3 = __refParamPtr3;
                fixed (int* __refParamPtr4 = &targetStartSnapTime)
                {
                    var __arg4 = __refParamPtr4;
                    fixed (int* __refParamPtr5 = &targetEndSnapTime)
                    {
                        var __arg5 = __refParamPtr5;
                        var __ret = __Internal.JsTTDGetSnapTimeTopLevelEventMove_0(runtimeHandle, moveMode, kthEvent, __arg3, __arg4, __arg5);
                        return __ret;
                    }
                }
            }
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Get the snapshot interval that bounds the target event time.</para>
        /// </summary>
        /// <param name="runtimeHandle">
        /// <para>The runtime handle that the script is executing in.</para>
        /// </param>
        /// <param name="targetEventTime">
        /// <para>The event time we want to get the interval for.</para>
        /// </param>
        /// <param name="startSnapTime">
        /// <para>The snapshot time that comes before the desired event.</para>
        /// </param>
        /// <param name="endSnapTime">
        /// <para>The snapshot time that comes after the desired event (-1 if the leg ends before a snapshot appears).</para>
        /// </param>
        public static _JsErrorCode JsTTDGetSnapShotBoundInterval(global::System.IntPtr runtimeHandle, long targetEventTime, out int startSnapTime, out int endSnapTime)
        {
            fixed (int* __refParamPtr2 = &startSnapTime)
            {
                var __arg2 = __refParamPtr2;
                fixed (int* __refParamPtr3 = &endSnapTime)
                {
                    var __arg3 = __refParamPtr3;
                    var __ret = __Internal.JsTTDGetSnapShotBoundInterval_0(runtimeHandle, targetEventTime, __arg2, __arg3);
                    return __ret;
                }
            }
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Get the snapshot interval that precedes the one given by currentSnapStartTime (or -1 if there is no such interval).</para>
        /// </summary>
        /// <param name="runtimeHandle">
        /// <para>The runtime handle that the script is executing in.</para>
        /// </param>
        /// <param name="currentSnapStartTime">
        /// <para>The current snapshot interval start time.</para>
        /// </param>
        /// <param name="previousSnapTime">
        /// <para>The resulting previous snapshot interval start time or -1 if no such time.</para>
        /// </param>
        public static _JsErrorCode JsTTDGetPreviousSnapshotInterval(global::System.IntPtr runtimeHandle, long currentSnapStartTime, out int previousSnapTime)
        {
            fixed (int* __refParamPtr2 = &previousSnapTime)
            {
                var __arg2 = __refParamPtr2;
                var __ret = __Internal.JsTTDGetPreviousSnapshotInterval_0(runtimeHandle, currentSnapStartTime, __arg2);
                return __ret;
            }
        }

        /// <param name="moveMode">
        /// <para>Additional flags for controling how the move is done.</para>
        /// </param>
        /// <param name="newTargetEventTime">
        /// <para>The updated target event time set according to the moveMode (-1 if not found).</para>
        /// </param>
        public static _JsErrorCode JsTTDPreExecuteSnapShotInterval(global::System.IntPtr runtimeHandle, long startSnapTime, long endSnapTime, _JsTTDMoveModes moveMode, out int newTargetEventTime)
        {
            fixed (int* __refParamPtr4 = &newTargetEventTime)
            {
                var __arg4 = __refParamPtr4;
                var __ret = __Internal.JsTTDPreExecuteSnapShotInterval_0(runtimeHandle, startSnapTime, endSnapTime, moveMode, __arg4);
                return __ret;
            }
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Move to the given top-level call event time (assuming JsTTDPrepContextsForTopLevelEventMove) was called previously to reset any script contexts.     This also computes the ready-to-run snapshot if needed.</para>
        /// </summary>
        /// <param name="runtimeHandle">
        /// <para>The runtime handle that the script is executing in.</para>
        /// </param>
        /// <param name="moveMode">
        /// <para>Additional flags for controling how the move is done.</para>
        /// </param>
        /// <param name="snapshotTime">
        /// <para>The event time that we will start executing from to move to the given target time.</para>
        /// </param>
        /// <param name="eventTime">
        /// <para>The event that we want to move to.</para>
        /// </param>
        public static _JsErrorCode JsTTDMoveToTopLevelEvent(global::System.IntPtr runtimeHandle, _JsTTDMoveModes moveMode, long snapshotTime, long eventTime)
        {
            var __ret = __Internal.JsTTDMoveToTopLevelEvent_0(runtimeHandle, moveMode, snapshotTime, eventTime);
            return __ret;
        }

        /// <summary>
        /// <para>TTD API -- may change in future versions:     Execute from the current point in the log to the end returning the error code.</para>
        /// </summary>
        /// <param name="moveMode">
        /// <para>Additional flags for controling how the move is done.</para>
        /// </param>
        /// <param name="rootEventTime">
        /// <para>The event time that we should move to next or notification (-1) that replay has ended.</para>
        /// </param>
        public static _JsErrorCode JsTTDReplayExecution(_JsTTDMoveModes* moveMode, out int rootEventTime)
        {
            fixed (int* __refParamPtr1 = &rootEventTime)
            {
                var __arg1 = __refParamPtr1;
                var __ret = __Internal.JsTTDReplayExecution_0(moveMode, __arg1);
                return __ret;
            }
        }
    }
}
